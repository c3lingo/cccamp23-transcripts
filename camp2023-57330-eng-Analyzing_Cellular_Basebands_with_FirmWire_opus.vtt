WEBVTT

00:00:00.000 --> 00:00:10.000
 [MUSIC]

00:00:10.000 --> 00:00:20.000
 [MUSIC]

00:00:20.000 --> 00:00:33.280
 >> Good morning everybody. I'm Dominik.

00:00:33.280 --> 00:00:36.360
 This is Marius, Dominuk NSR.

00:00:36.360 --> 00:00:42.840
 We're going to talk about how to analyze cellular basements,

00:00:42.840 --> 00:00:45.640
 and how to find bugs in them,

00:00:45.640 --> 00:00:48.000
 and about our tool which is called FirmWire,

00:00:48.000 --> 00:00:50.240
 which helps you do this.

00:00:50.240 --> 00:00:52.680
 >> Now that we have slides set up,

00:00:52.680 --> 00:00:53.960
 good morning all from my side,

00:00:53.960 --> 00:00:56.200
 I'm NSR or Marius.

00:00:56.200 --> 00:01:00.040
 Before we start, we just want to properly acknowledge the full team.

00:01:00.040 --> 00:01:01.480
 The tool FirmWire has been

00:01:01.480 --> 00:01:05.120
 a multi-year effort between a lot of different people,

00:01:05.120 --> 00:01:07.040
 a lot of different academic institutions,

00:01:07.040 --> 00:01:10.400
 and it's really a massive team effort,

00:01:10.400 --> 00:01:13.480
 and we really want to shout out to all the people here on the slide.

00:01:13.480 --> 00:01:14.720
 Now, yeah.

00:01:14.720 --> 00:01:16.520
 >> All right.

00:01:16.520 --> 00:01:23.200
 >> Now, without further ado,

00:01:23.200 --> 00:01:29.040
 let's talk about what will be the next 45 minutes of our and your life,

00:01:29.040 --> 00:01:30.440
 if you decide to stay here.

00:01:30.440 --> 00:01:34.060
 So we will talk about basements and specific cellular basements.

00:01:34.060 --> 00:01:39.080
 We will look into how to emulate them and why we emulate them.

00:01:39.080 --> 00:01:42.080
 Using this emulation, we will look into

00:01:42.080 --> 00:01:45.640
 different exploration capabilities we have with our FirmWire tool,

00:01:45.640 --> 00:01:47.880
 to then start doing the fun stuff.

00:01:47.880 --> 00:01:49.480
 We will look into fuzzing,

00:01:49.480 --> 00:01:52.320
 which ultimately will lead to crashes,

00:01:52.320 --> 00:01:53.720
 which we will talk a lot of it.

00:01:53.720 --> 00:01:57.760
 Then lastly, we will talk about how we used

00:01:57.760 --> 00:02:01.520
 our tool to scale up what we got on crashes.

00:02:01.520 --> 00:02:04.040
 >> Yeah. So what is this basement?

00:02:04.040 --> 00:02:05.440
 I mean, you all found your way here,

00:02:05.440 --> 00:02:08.600
 so you must know at least that it's interesting.

00:02:08.600 --> 00:02:11.640
 But just to give a short introduction,

00:02:11.640 --> 00:02:13.360
 I, in the beginning,

00:02:13.360 --> 00:02:15.600
 before I started this project with all these fine people,

00:02:15.600 --> 00:02:18.360
 didn't know that a basement in a smartphone,

00:02:18.360 --> 00:02:20.960
 the thing that actually talks to the cell tower,

00:02:20.960 --> 00:02:24.440
 is its own dedicated processor.

00:02:24.440 --> 00:02:28.360
 So it's completely independent of the application process,

00:02:28.360 --> 00:02:31.600
 the thing that runs your apps like Android or iOS.

00:02:31.600 --> 00:02:33.520
 It has its own operating system,

00:02:33.520 --> 00:02:37.160
 usually like a proprietary real-time operating system that just runs.

00:02:37.160 --> 00:02:40.400
 We're going to go into details, of course, during the talk.

00:02:40.400 --> 00:02:45.880
 But the interesting thing is that it speaks all the cellular protocols

00:02:45.880 --> 00:02:49.000
 from way back in the early 90s that you know.

00:02:49.000 --> 00:02:53.360
 If you're in anger that you still have edge somewhere,

00:02:53.360 --> 00:02:55.280
 then it's probably still

00:02:55.280 --> 00:02:58.480
 the space and processes that runs all of the communication.

00:02:58.480 --> 00:03:06.440
 It's millions of lines of C code that are not really looked into

00:03:06.440 --> 00:03:09.480
 by anybody on the outside world like us.

00:03:09.480 --> 00:03:12.880
 This is what we set out to change.

00:03:12.880 --> 00:03:15.440
 Basements are super juicy.

00:03:15.440 --> 00:03:19.320
 As I said, they go back way to the 90s,

00:03:19.320 --> 00:03:23.320
 when security was not really a big thing yet.

00:03:23.320 --> 00:03:26.360
 We didn't know that you could

00:03:26.360 --> 00:03:28.680
 run random stuff when you had a stack overflow.

00:03:28.680 --> 00:03:31.960
 I guess people knew, but I didn't. I was a kid.

00:03:31.960 --> 00:03:37.000
 The nice thing is that if you think of some complex spec,

00:03:37.000 --> 00:03:39.800
 it's probably implemented in the basement.

00:03:39.800 --> 00:03:45.240
 It's implemented in a proprietary way and hasn't been looked at much.

00:03:45.240 --> 00:03:49.800
 Like XML parsers, DNS parsers, TLS.

00:03:49.800 --> 00:03:51.880
 There's a whole TCP stack, of course,

00:03:51.880 --> 00:03:55.120
 and it's because who doesn't want a whole TCP stack.

00:03:55.120 --> 00:03:57.280
 There's a lot of ASN1 decoding.

00:03:57.280 --> 00:04:01.840
 If you know ASN1, it's like this binary format that breaks a lot,

00:04:01.840 --> 00:04:04.280
 used to break a lot at least.

00:04:04.280 --> 00:04:08.160
 It's a tempting initial point of entry onto smartphones

00:04:08.160 --> 00:04:11.360
 just because it's right there.

00:04:11.360 --> 00:04:14.840
 It's the first thing that receives every message over the air.

00:04:14.840 --> 00:04:18.960
 There have been multiple bugs if you follow the security stuff

00:04:18.960 --> 00:04:21.800
 recently on bigger conferences.

00:04:21.800 --> 00:04:27.320
 There was this amazing talk by Natalie who found bugs in smartphone basements,

00:04:27.320 --> 00:04:32.400
 and they were not only exploitable from if you're next to it with an SDR,

00:04:32.400 --> 00:04:36.000
 but they were exploitable over the real air, like over the internet.

00:04:36.000 --> 00:04:39.800
 So you needed a phone number to exploit the phone and run code on it.

00:04:39.800 --> 00:04:43.680
 There was this talk by Amit who was also looking into ASN1

00:04:43.680 --> 00:04:46.000
 and how it was broken in the past.

00:04:46.000 --> 00:04:49.280
 And then there was this talk by the Android Red team

00:04:49.280 --> 00:04:53.800
 about how they tried to secure the baseband

00:04:53.800 --> 00:04:57.520
 and about how other bugs they found as well.

00:04:57.520 --> 00:05:00.040
 And all of these talks were just this year,

00:05:00.040 --> 00:05:03.400
 so there must be something about this baseband, right, which is interesting.

00:05:03.400 --> 00:05:06.480
 So let's start from the basic principles

00:05:06.480 --> 00:05:12.000
 and look a little bit about what are these real-time operating systems running on there.

00:05:12.000 --> 00:05:13.880
 In a nutshell, it's an operating system,

00:05:13.880 --> 00:05:17.200
 and it has all the things you would expect from an operating system to have, right?

00:05:17.200 --> 00:05:19.760
 There's a scheduler, a timer, some interrupts.

00:05:19.760 --> 00:05:24.040
 It has some notion of processes, and AirTOS is usually called tasks,

00:05:24.040 --> 00:05:27.160
 and these tasks can interact with each other via messages.

00:05:27.160 --> 00:05:30.720
 So that's a core operating system in itself.

00:05:30.720 --> 00:05:34.440
 The baseband AirTOS is responsible for mainly two things.

00:05:34.440 --> 00:05:36.760
 One is to interact with the hardware peripherals,

00:05:36.760 --> 00:05:41.000
 which most of the time will trigger some over-the-air interaction,

00:05:41.000 --> 00:05:43.840
 so some digital signal processors and similar.

00:05:43.840 --> 00:05:48.360
 But also it has, for instance, a shared memory region with the application processor,

00:05:48.360 --> 00:05:51.320
 so with the Android or iOS side of things,

00:05:51.320 --> 00:05:55.720
 basically to support messages and do all the fancy things we need to do for calling,

00:05:55.720 --> 00:05:57.920
 have mobile internet, and so on.

00:05:57.920 --> 00:06:01.440
 What's interesting is that the scheduler stack,

00:06:01.440 --> 00:06:03.640
 so it's a lot of specifications,

00:06:03.640 --> 00:06:06.120
 but usually the different parts of the scheduler stacks

00:06:06.120 --> 00:06:09.000
 maps pretty much one-to-one to the different tasks.

00:06:09.000 --> 00:06:13.160
 And we have here one, let's say, heavily simplified tasks

00:06:13.160 --> 00:06:15.880
 for demonstration purposes.

00:06:15.880 --> 00:06:19.160
 Alright, so the interesting pieces, of course, are all stubbed out,

00:06:19.160 --> 00:06:21.600
 and this would not compile or run.

00:06:21.600 --> 00:06:25.840
 But just to give you information, this is like every single task

00:06:25.840 --> 00:06:28.520
 that runs in a baseband, and there are many,

00:06:28.520 --> 00:06:32.960
 would initialize at boot or whenever the task starts,

00:06:32.960 --> 00:06:34.600
 and then it'll just run forever.

00:06:34.600 --> 00:06:39.680
 It'll just loop, and this message receive function you see here, this blocks,

00:06:39.680 --> 00:06:43.160
 and waits for a new message that it will receive from somewhere,

00:06:43.160 --> 00:06:45.320
 you know, down the stack or up the stack.

00:06:45.320 --> 00:06:48.680
 And then it'll do something with it, so if it would be an ASN1 parser,

00:06:48.680 --> 00:06:53.640
 it would parse the message and then have some outgoing message afterwards,

00:06:53.640 --> 00:06:57.960
 potentially, or multiple, and send these to other tasks in the baseband,

00:06:57.960 --> 00:07:01.440
 and then the message is owned, so it has to free it.

00:07:01.440 --> 00:07:05.960
 And the thing that I found interesting, or that is very true

00:07:05.960 --> 00:07:08.040
 across at least all basebands we looked at,

00:07:08.040 --> 00:07:13.080
 is that every single, the spec in the cellular modem is big.

00:07:13.080 --> 00:07:18.800
 The cellular spec is big, and in the modem, you have almost a one-to-one mapping

00:07:18.800 --> 00:07:23.120
 between some of the, at least all of the different parts of the spec

00:07:23.120 --> 00:07:28.600
 and a task on the other side, and there is multiple layers in the cellular spec,

00:07:28.600 --> 00:07:33.880
 and the lower layer task will forward stuff up the spec, the stack,

00:07:33.880 --> 00:07:36.640
 oh my god, sorry, good morning, it's early.

00:07:36.640 --> 00:07:42.520
 And then at some point it'll reach the application processor via IPC.

00:07:42.520 --> 00:07:46.840
 So now, if we want to set up and find bugs in the baseband, right,

00:07:46.840 --> 00:07:51.800
 there are multiple approaches, and initially, when considering this work,

00:07:51.800 --> 00:07:54.960
 we were mostly looking in three, which were over-the-air testing,

00:07:54.960 --> 00:07:57.040
 static analysis, and emulation.

00:07:57.040 --> 00:08:01.360
 There's also a hidden force one, which is just reading the specs.

00:08:01.360 --> 00:08:05.760
 Some people are good at it and doing it and finding bugs by just reading it.

00:08:05.760 --> 00:08:07.040
 We are not these people.

00:08:07.040 --> 00:08:10.200
 Yeah, we are not these people, and we don't have the endurance to read

00:08:10.200 --> 00:08:14.000
 hundreds and hundreds and hundreds of pages, like these specs are really big.

00:08:14.000 --> 00:08:17.080
 So, yeah, one common approach was just over-the-air testing, right,

00:08:17.080 --> 00:08:21.000
 like set up the phone, ideally in some air-f shielded environment,

00:08:21.000 --> 00:08:23.960
 and send all sorts of fun messages to it.

00:08:23.960 --> 00:08:28.080
 We discarded this because most of the time we will not see what's going on, right?

00:08:28.080 --> 00:08:30.360
 We send a message, the phone may crash, may not crash,

00:08:30.360 --> 00:08:34.800
 and we have basically no introspection without really digging deeper

00:08:34.800 --> 00:08:38.320
 into hacking the phone to be able to extract those.

00:08:38.320 --> 00:08:42.720
 Another approach would be static analyzers, so taking the baseband binary

00:08:42.720 --> 00:08:47.720
 and just using some static analysis tools or symbolic execution, you name it.

00:08:47.720 --> 00:08:52.320
 The issue here is that these firmwares, the cellular baseband firmware,

00:08:52.320 --> 00:08:53.920
 is really, really complex.

00:08:53.920 --> 00:08:56.920
 It has a lot of different code indirections, a lot of initializations,

00:08:56.920 --> 00:09:02.240
 and our experience was that why static analysis may work for some part,

00:09:02.240 --> 00:09:07.200
 like a specific task or decoders, like for looking at the baseband in a whole,

00:09:07.200 --> 00:09:11.320
 it doesn't scale enough without giving too many false positives or other problems.

00:09:11.320 --> 00:09:17.640
 So we decided to go for emulation, so trying to basically take the full baseband firmware

00:09:17.640 --> 00:09:20.680
 and start it from the first instruction where it should be executed

00:09:20.680 --> 00:09:25.600
 and then executed all the way to wherever you want to go.

00:09:25.600 --> 00:09:27.960
 And that's why we created firmware.

00:09:27.960 --> 00:09:30.360
 It is the first open source baseband emulator.

00:09:30.360 --> 00:09:32.520
 Full system baseband emulator.

00:09:32.520 --> 00:09:35.440
 Sorry, yes, it's a fine distinction.

00:09:35.440 --> 00:09:39.000
 The first one that is able to run and boot a baseband from scratch, basically.

00:09:39.000 --> 00:09:43.720
 So you can drop in a binary-only baseband, you don't need source, you don't need symbols,

00:09:43.720 --> 00:09:48.440
 drop it in there and it'll boot, well, for those that are supported.

00:09:48.440 --> 00:09:52.440
 We support, but we did try it on over 200 firmware images

00:09:52.440 --> 00:09:55.720
 across nine different phone models and two baseband vendors.

00:09:55.720 --> 00:09:58.480
 So the phone vendors themselves may be different,

00:09:58.480 --> 00:10:03.080
 but there's only like five or so actual baseband vendors.

00:10:03.080 --> 00:10:06.560
 The ones that we looked at are MediaTek and Samsung Exynos.

00:10:06.560 --> 00:10:11.600
 There's other notable ones such as Unisoc, Qualcomm,

00:10:11.600 --> 00:10:15.400
 and then there used to be Intel, but it got bought by Apple.

00:10:15.400 --> 00:10:24.600
 And then there is also Huawei's own high-silicon stuff that people also looked at in the past.

00:10:24.600 --> 00:10:28.120
 Sorry for if I forgot any baseband vendors.

00:10:28.120 --> 00:10:34.000
 Let's see how our emulator looks like with an actual baseband.

00:10:34.000 --> 00:10:39.480
 So we pre-recorded all the demos just to make it easier for us, I guess, the demo gods.

00:10:39.480 --> 00:10:42.160
 I hope it's somewhat visible today.

00:10:42.160 --> 00:10:43.920
 It's not too sunny, so it should be fine.

00:10:43.920 --> 00:10:46.520
 Right, so we start firmware, which is our emulator.

00:10:46.520 --> 00:10:48.000
 We give it a modem.bin.

00:10:48.000 --> 00:10:52.920
 The modem.bin file is a Samsung, in this case, Shannon baseband

00:10:52.920 --> 00:10:55.760
 that we downloaded from somewhere in the internet.

00:10:55.760 --> 00:11:00.920
 So we downloaded the whole Android image and then we extracted the modem file from there.

00:11:00.920 --> 00:11:07.560
 This was not encrypted, which makes it, of course, nice for benign firmware analysis like ours.

00:11:07.560 --> 00:11:10.640
 And then you see here that it boots and it locks a ton of stuff.

00:11:10.640 --> 00:11:14.440
 On the very left, you see the timestamp, then you see the task,

00:11:14.440 --> 00:11:22.120
 including what the original name was, and then you see even the C file where this originated.

00:11:22.120 --> 00:11:26.160
 So this is present somewhere in the firmware.

00:11:26.160 --> 00:11:30.440
 We need to reverse engineer it to even get these locks in the first place.

00:11:30.440 --> 00:11:37.440
 And then you saw that this BTL task kept popping up and the last few executions looked the same.

00:11:37.440 --> 00:11:39.080
 This is because we were in the main loop.

00:11:39.080 --> 00:11:44.560
 So the firmware has fully booted at this point and then just loops around and waits for things to happen.

00:11:44.560 --> 00:11:48.040
 So it waits for some communication from the network,

00:11:48.040 --> 00:11:53.040
 which never comes because it is not really connected to anything at this point.

00:11:53.040 --> 00:11:54.240
 OK, very cool.

00:11:54.240 --> 00:12:02.440
 So under the hood, how does Firmwire work to enable these millions of log messages just flying by?

00:12:02.440 --> 00:12:05.440
 So we split the framework in two parts.

00:12:05.440 --> 00:12:09.560
 One of the vendor plugins and the other is the emulation core.

00:12:09.560 --> 00:12:15.320
 And the vendor plugins is basically, as the name suggests, specific for every of the baseband vendors we looked at.

00:12:15.320 --> 00:12:19.200
 So we have one for MediaTag, one for Samsung, Shannon, Exynos.

00:12:19.200 --> 00:12:25.000
 And basically the vendor plugin takes this firmware binary and does a full lot of pre-processing.

00:12:25.000 --> 00:12:34.560
 It tries to figure out where the memory mappings, it uses some magic called pattern DB to resolve symbols, which we will need later on.

00:12:34.560 --> 00:12:41.720
 And once it gathered all this information, it passes on to the emulation core, which then does the emulation.

00:12:41.720 --> 00:12:49.280
 So it tries to run the code and it also emulates the peripheral it needs to interact to a point where the baseband runs.

00:12:49.280 --> 00:12:52.960
 So it's not a full truthful emulation, but it helps us to get it running.

00:12:52.960 --> 00:12:58.880
 And it provides us a lot of different introspection capabilities, which we'll talk about in a bit, I think.

00:12:58.880 --> 00:13:02.480
 Right. So the vendor plugins are a firmware loader.

00:13:02.480 --> 00:13:07.240
 Then we have different CPU architecture support things in there.

00:13:07.240 --> 00:13:09.000
 So MediaTag is usually weird.

00:13:09.000 --> 00:13:12.760
 The one that we support is a MIPS 16 E2.

00:13:12.760 --> 00:13:19.040
 The latest 5G ones switch to NanoWave, which is also weird, but needs extra work to get going.

00:13:19.040 --> 00:13:23.560
 Then for Shannon, we support ARM Cortex R stuff, which is also one generation older.

00:13:23.560 --> 00:13:27.880
 The latest ones switch to Cortex A, so actually application processors.

00:13:27.880 --> 00:13:33.520
 So next to your application processor, you now have an application processor.

00:13:33.520 --> 00:13:42.160
 There's some SOC specific, as Mario said, memory mappings, etc., peripherals that the baseband tries to talk to.

00:13:42.160 --> 00:13:46.080
 Like there would be an antenna or something.

00:13:46.080 --> 00:13:48.480
 Anyway, that we just usually step out.

00:13:48.480 --> 00:13:51.040
 We just want the thing to boot and think there's something.

00:13:51.040 --> 00:13:55.880
 We don't care if it looks real or not, just real enough for the baseband to boot.

00:13:55.880 --> 00:14:00.640
 And then we have functionalities for each vendor to recover the baseband internal logs.

00:14:00.640 --> 00:14:03.120
 So they're not actually logging all of this necessarily.

00:14:03.120 --> 00:14:06.960
 They just do some proprietary stuff and then have their logs somewhere else.

00:14:06.960 --> 00:14:10.240
 And we show them, which is nice.

00:14:10.240 --> 00:14:14.800
 And then we have this pattern DB, which is used to basically find...

00:14:14.800 --> 00:14:17.640
 So we don't want to hard-code everything, so we have this pattern DB.

00:14:17.640 --> 00:14:19.960
 This is how one pattern definition would look like.

00:14:19.960 --> 00:14:24.440
 We have a pattern. It looks a bit like a regex. It has similar functionalities.

00:14:24.440 --> 00:14:29.080
 It's like these bytes look for these bytes, and then these are like wildcard bytes.

00:14:29.080 --> 00:14:32.640
 There's other options in this pattern.

00:14:32.640 --> 00:14:36.000
 For example, is it required that this pattern exists?

00:14:36.000 --> 00:14:38.840
 Is it a fatal error if it doesn't exist?

00:14:38.840 --> 00:14:44.160
 The entry point or something like that, the main map of all tasks.

00:14:44.160 --> 00:14:47.760
 If this doesn't exist, then we just don't want to boot. It doesn't work.

00:14:47.760 --> 00:14:50.520
 And then we can run some code as well.

00:14:50.520 --> 00:14:54.360
 And there's not too many patterns needed to get a firmware booting actually.

00:14:54.360 --> 00:14:59.440
 So for Samsung, we used 18, and Mediatek only 9 to get the thing running.

00:14:59.440 --> 00:15:03.560
 And now we have this pre-processed image from the Wendel plugin,

00:15:03.560 --> 00:15:06.720
 and plug it into the emulation core.

00:15:06.720 --> 00:15:11.240
 The emulation core, as we saw, allows us to see all those logs,

00:15:11.240 --> 00:15:13.240
 then flying by during runtime.

00:15:13.240 --> 00:15:15.800
 It allows us also to just play around with the firmware.

00:15:15.800 --> 00:15:20.760
 We are GDB, an interactive console, and it also enables us to do fast testing.

00:15:20.760 --> 00:15:24.680
 We built the emulation core using two frameworks.

00:15:24.680 --> 00:15:29.680
 One is Panda, which is a QEMU-based emulator,

00:15:29.680 --> 00:15:33.520
 which was originally designed for Recod and Replay and reverse engineering.

00:15:33.520 --> 00:15:38.840
 But what it has, it's a lot of nice features to hook into the different parts of the emulation.

00:15:38.840 --> 00:15:43.760
 And also it comes by now as a Python library, so we can easily plug it.

00:15:43.760 --> 00:15:46.680
 And the second framework we used was AvaTattoo,

00:15:46.680 --> 00:15:50.200
 which is basically a framework for orchestrating,

00:15:50.200 --> 00:15:53.160
 so basically to tell Panda how to run in similar.

00:15:53.160 --> 00:15:58.520
 And it also allows us to basically stop and implement the peripherals we need.

00:15:58.520 --> 00:16:02.800
 One other functionality provided by the emulation core, which we heavily use,

00:16:02.800 --> 00:16:07.760
 is the modkit, or the modification kit, which allows us to inject custom tasks.

00:16:07.760 --> 00:16:13.280
 So we can extend the functionality of the emulated baseband by writing our own code,

00:16:13.280 --> 00:16:16.640
 writing our own AirToss task for the baseband,

00:16:16.640 --> 00:16:19.400
 and put it into the emulated version of the firmware.

00:16:19.400 --> 00:16:22.280
 There's a list of all tasks basically in the baseband,

00:16:22.280 --> 00:16:27.160
 and we just, at boot time or at any time, slot another one in there, like in the end.

00:16:27.160 --> 00:16:28.560
 That's our own task then.

00:16:28.560 --> 00:16:33.080
 Yeah, and then we use patternDB again to find the symbols the task needs,

00:16:33.080 --> 00:16:37.120
 so we can use actual functionality which is already there in the baseband.

00:16:37.120 --> 00:16:40.520
 Like we can use debug log functions,

00:16:40.520 --> 00:16:44.160
 or we can use different hooks for allocating memory and so on.

00:16:44.160 --> 00:16:49.920
 So we can really use this modkit to do a full bunch of interesting things.

00:16:52.000 --> 00:16:54.520
 So now let's look at how to explore this.

00:16:54.520 --> 00:16:57.800
 Exactly. So I briefly mentioned before we have the console,

00:16:57.800 --> 00:17:03.520
 which is I think what at least I use the most when playing with firmware.

00:17:03.520 --> 00:17:07.640
 And it's basically a Python console which directly hooks us

00:17:07.640 --> 00:17:10.840
 during the running emulation into the emulating process.

00:17:10.840 --> 00:17:14.880
 So we have a reference to, in this case, the Shannon machine object.

00:17:14.880 --> 00:17:18.920
 So this is a firmware machine which allows us to control the emulation.

00:17:18.920 --> 00:17:21.520
 Like we can start and stop the emulation, we can do breakpoints,

00:17:21.520 --> 00:17:23.240
 we can read or write memory.

00:17:23.240 --> 00:17:27.560
 And all of this is built on top of Jupyter notebooks,

00:17:27.560 --> 00:17:29.160
 not notebooks, console, sorry.

00:17:29.160 --> 00:17:32.520
 And another cool thing on top of these consoles,

00:17:32.520 --> 00:17:38.160
 or integrated in the console, is we have our own task that gets injected as well.

00:17:38.160 --> 00:17:41.720
 Like you can write your own task, but we inject this glink task,

00:17:41.720 --> 00:17:43.920
 which is the guest link task.

00:17:43.920 --> 00:17:47.880
 It's a custom task that we created that basically forwards things

00:17:47.880 --> 00:17:51.840
 from this Python console inside the baseband.

00:17:51.840 --> 00:17:55.000
 So you are on the host, you're playing with your Python,

00:17:55.000 --> 00:17:58.680
 you can do, as you can see on the right, you can get this glink,

00:17:58.680 --> 00:18:01.080
 handle to this glink task on the inside,

00:18:01.080 --> 00:18:03.160
 and then you can call things on this glink.

00:18:03.160 --> 00:18:08.320
 So you can create blocks, so you can basically allocate chunks of memory

00:18:08.320 --> 00:18:09.800
 inside the baseband.

00:18:09.800 --> 00:18:13.800
 You can send messages from inside the baseband to other tasks

00:18:13.800 --> 00:18:15.320
 inside the baseband again.

00:18:15.320 --> 00:18:18.760
 You can set events, which is a thing that is internal to the baseband as well.

00:18:18.760 --> 00:18:21.560
 You can do like, hey, there's something happening.

00:18:21.560 --> 00:18:23.560
 And then you can also get values out.

00:18:23.560 --> 00:18:27.840
 So you don't need to recompile your task and re-inject your task every time.

00:18:27.840 --> 00:18:31.240
 You can basically play around with it from a Python to a console,

00:18:31.240 --> 00:18:33.320
 which is really handy.

00:18:33.320 --> 00:18:37.440
 And then another thing that we use heavily now in the next demo

00:18:37.440 --> 00:18:41.680
 is basically we can snapshot the whole thing at any point in time.

00:18:41.680 --> 00:18:43.880
 So after, let's say, the boot takes a bit.

00:18:43.880 --> 00:18:46.640
 We don't want to-- or we are looking at one specific thing.

00:18:46.640 --> 00:18:52.000
 We don't want to reset the whole thing and reboot to this place every time.

00:18:52.000 --> 00:18:53.120
 And we can take a snapshot.

00:18:53.120 --> 00:18:57.040
 It uses the QEMU internal snapshots, and it has enrichment

00:18:57.040 --> 00:18:59.880
 with these peripherals that we write, for example.

00:18:59.880 --> 00:19:02.440
 Like, if they have a specific state, we can also snapshot this,

00:19:02.440 --> 00:19:04.040
 which is handy.

00:19:04.040 --> 00:19:07.840
 Yeah, and let's see how this looks like.

00:19:07.840 --> 00:19:10.640
 Yeah, so here, first of all, we start a TMUX session,

00:19:10.640 --> 00:19:12.080
 which we don't see right now.

00:19:12.080 --> 00:19:15.240
 But we basically need two windows, because in one,

00:19:15.240 --> 00:19:18.680
 we will have FirmWire running, and in the other, our console.

00:19:18.680 --> 00:19:22.080
 So we restore, and the very first, we say that we want to restore

00:19:22.080 --> 00:19:24.440
 a snapshot, which is the one for this demo,

00:19:24.440 --> 00:19:26.480
 and that we want to enable the console.

00:19:26.480 --> 00:19:31.640
 So now we see FirmWire booting up and can attach on our second terminal,

00:19:31.640 --> 00:19:38.920
 which we will start here, to-- well, to FirmWire, to our console.

00:19:38.920 --> 00:19:43.440
 And once we're in here, we-- yeah, we're typing.

00:19:43.440 --> 00:19:46.760
 We can see we have the self object, which is the Shannon machine.

00:19:46.760 --> 00:19:50.920
 And we can just say, hey, let's emulate for, I don't know, one second.

00:19:50.920 --> 00:19:54.720
 And we see here some of the messages flying by, so we emulate it a bit.

00:19:54.720 --> 00:19:59.480
 And now we want to show a little bit about G-Link or Guest Link.

00:19:59.480 --> 00:20:01.200
 Oh, the demo is broken.

00:20:01.200 --> 00:20:01.960
 Nice.

00:20:01.960 --> 00:20:02.480
 Nice.

00:20:02.480 --> 00:20:03.360
 Thank you.

00:20:03.360 --> 00:20:07.040
 Yeah, anyhow, we got a reference to the G-Link peripheral.

00:20:07.040 --> 00:20:11.200
 And we try to do create block, so we want to--

00:20:11.200 --> 00:20:12.120
 Oh, no.

00:20:12.120 --> 00:20:12.600
 Yeah.

00:20:12.600 --> 00:20:13.360
 Yeah.

00:20:13.360 --> 00:20:16.760
 Think it's resolutions from the projector and so on.

00:20:16.760 --> 00:20:17.680
 It worked yesterday.

00:20:17.680 --> 00:20:20.680
 Yeah, anyhow, we create a memory block, and we run again,

00:20:20.680 --> 00:20:25.200
 because this is an interactive task, so it needs to run to allocate the block,

00:20:25.200 --> 00:20:28.240
 which we have now at this address down here.

00:20:28.240 --> 00:20:32.520
 And this is a freshly allocated block.

00:20:32.520 --> 00:20:36.960
 So we just use the read memory functionality to read 40 bytes.

00:20:36.960 --> 00:20:38.840
 That's the amount of what we allocated.

00:20:38.840 --> 00:20:42.480
 And we see these as all zeros for now, which makes sense.

00:20:42.480 --> 00:20:44.280
 It's a freshly allocated block.

00:20:44.280 --> 00:20:51.480
 So let's change this a bit and write some memory in a very broken up way.

00:20:51.480 --> 00:20:57.040
 And yeah, eventually, we write 40 A's to this location.

00:20:57.040 --> 00:20:58.280
 And here we are.

00:20:58.280 --> 00:20:59.520
 It's zero for now.

00:20:59.520 --> 00:21:02.280
 Let's return, and if we read it, we have 40 A's there.

00:21:02.280 --> 00:21:08.400
 So this will show a little bit how Filmwire works under the hood.

00:21:08.400 --> 00:21:14.760
 [APPLAUSE]

00:21:14.760 --> 00:21:15.280
 Sweet.

00:21:15.280 --> 00:21:19.880
 So what can we do with-- we can now interact with things in the basement.

00:21:19.880 --> 00:21:21.000
 What does that mean?

00:21:21.000 --> 00:21:22.200
 What is a thing in the basement?

00:21:22.200 --> 00:21:27.840
 As I said earlier, every single cellular specification

00:21:27.840 --> 00:21:31.360
 is somewhat reflected in one of these tasks.

00:21:31.360 --> 00:21:34.880
 So this is how, for example, the 2G protocol stack would look like.

00:21:34.880 --> 00:21:38.360
 2G, of course, is still relevant because it's still enabled everywhere,

00:21:38.360 --> 00:21:39.240
 especially in Germany.

00:21:39.240 --> 00:21:41.800
 You should know this.

00:21:41.800 --> 00:21:45.520
 And well, you can turn it off in more modern phones,

00:21:45.520 --> 00:21:48.640
 but it's uncommon that people do that.

00:21:48.640 --> 00:21:52.120
 So you have these different layers in the specification.

00:21:52.120 --> 00:21:54.040
 And then there's different tasks.

00:21:54.040 --> 00:21:57.320
 So there is, for example, in this case, a CC, which

00:21:57.320 --> 00:21:59.440
 is sort of a call control task.

00:21:59.440 --> 00:22:02.720
 And the call control task would give you control.

00:22:02.720 --> 00:22:05.640
 It doesn't really matter what all of these abbreviations are.

00:22:05.640 --> 00:22:07.760
 If you have no idea what any of these are,

00:22:07.760 --> 00:22:11.360
 you can go to 3GPP.guru, which is the most amazing website

00:22:11.360 --> 00:22:12.640
 for these sort of things.

00:22:12.640 --> 00:22:14.120
 Just type in the abbreviation.

00:22:14.120 --> 00:22:16.720
 It'll tell you at least the location and spec.

00:22:16.720 --> 00:22:19.960
 You will still probably have to ask JGPT for what the spec actually means,

00:22:19.960 --> 00:22:22.040
 but that's a different story.

00:22:22.040 --> 00:22:25.680
 Anyway, this CC task is called control task.

00:22:25.680 --> 00:22:30.440
 It is for the task that does everything for circuit switch calling.

00:22:30.440 --> 00:22:34.400
 So in the more modern spec, if you call somebody,

00:22:34.400 --> 00:22:38.720
 it's actually just a voice over IP or LTE, voice over LTE call.

00:22:38.720 --> 00:22:41.800
 So it's only bytes and packets flying around.

00:22:41.800 --> 00:22:43.280
 Back in the day, it was circuit switch.

00:22:43.280 --> 00:22:46.840
 It was already bytes, but it was circuit switched.

00:22:46.840 --> 00:22:49.720
 And there's still bytes sent over the air.

00:22:49.720 --> 00:22:54.200
 And then there's different messages that this CC task will basically

00:22:54.200 --> 00:22:56.520
 eat and do something with it.

00:22:56.520 --> 00:23:00.680
 So there's the CC setup message that is sent from the network

00:23:00.680 --> 00:23:05.600
 over the air in bytes to the mobile device, so to our baseband.

00:23:05.600 --> 00:23:07.560
 And then the packet is made up.

00:23:07.560 --> 00:23:10.200
 If you want to know more about what bytes we're

00:23:10.200 --> 00:23:15.880
 going to send in the next demo, they're aligned with the spec.

00:23:15.880 --> 00:23:20.680
 And then we can actually call ourselves, which is kind of cool.

00:23:20.680 --> 00:23:21.560
 Right.

00:23:21.560 --> 00:23:22.120
 Let's see if--

00:23:22.120 --> 00:23:24.520
 Let's do this and hope that it works.

00:23:24.520 --> 00:23:25.040
 Demo goes.

00:23:25.040 --> 00:23:25.920
 Let's go.

00:23:25.920 --> 00:23:26.760
 Again, t-marks.

00:23:26.760 --> 00:23:29.040
 We're starting again from the snapshot.

00:23:29.040 --> 00:23:32.760
 And attach again to the console.

00:23:32.760 --> 00:23:34.720
 Now here, we prepared already the bytes we

00:23:34.720 --> 00:23:40.320
 want to send for this call setup message just to basically have it ready.

00:23:40.320 --> 00:23:44.080
 So it's what we call the call in it payload or call setup.

00:23:44.080 --> 00:23:47.080
 And these are the magical bytes we got by reading the spec

00:23:47.080 --> 00:23:49.600
 and doing a little bit of reverse engineering.

00:23:49.600 --> 00:23:53.160
 We're getting the guest link task again, or the guest link peripheral.

00:23:53.160 --> 00:23:56.920
 And one little thing we will do here before actually sending the setup

00:23:56.920 --> 00:23:59.760
 message is sending another message to the CC task, which

00:23:59.760 --> 00:24:02.760
 will trigger initial evasion of the CC task.

00:24:02.760 --> 00:24:04.720
 Because by default, it just spin up.

00:24:04.720 --> 00:24:05.600
 It's booted.

00:24:05.600 --> 00:24:08.520
 But it still would wait for the baseband to complete other tasks

00:24:08.520 --> 00:24:11.960
 before being ready to process over the air messages.

00:24:11.960 --> 00:24:15.040
 And yes, finding this was painful reverse engineering.

00:24:15.040 --> 00:24:15.680
 Yeah.

00:24:15.680 --> 00:24:22.560
 And yeah, the magic message for it is just being typed magically in here.

00:24:22.560 --> 00:24:23.480
 And yeah, we send it.

00:24:23.480 --> 00:24:26.440
 And we can see here, if we look a little bit,

00:24:26.440 --> 00:24:29.600
 that a lot of initialization happened.

00:24:29.600 --> 00:24:38.400
 And we saw here that initialization functionality is going on.

00:24:38.400 --> 00:24:38.960
 OK.

00:24:38.960 --> 00:24:48.680
 With this, we can now move on and try to send the call setup message,

00:24:48.680 --> 00:24:50.600
 which requires a slightly different header.

00:24:50.600 --> 00:24:53.480
 So these are headers for the messages being changed down here.

00:24:53.480 --> 00:24:59.040
 And then we put the actual payload and run the emulation again.

00:24:59.040 --> 00:25:01.520
 And we can see here already here, down here,

00:25:01.520 --> 00:25:04.400
 there's radio message call confirmed written.

00:25:04.400 --> 00:25:08.600
 And we can also see a lot of other CC functionality flying by

00:25:08.600 --> 00:25:09.200
 and being used.

00:25:09.200 --> 00:25:11.640
 So we basically now, in quotation marks,

00:25:11.640 --> 00:25:14.760
 called our emulated baseband or gave it a signaling message,

00:25:14.760 --> 00:25:18.480
 like hey, here's a call incoming.

00:25:18.480 --> 00:25:22.880
 So there's some logs that indicate that the baseband has actually

00:25:22.880 --> 00:25:26.600
 received our call and thinks that there's an incoming call.

00:25:26.600 --> 00:25:27.280
 Yeah.

00:25:27.280 --> 00:25:31.120
 So this is what we do when-- or what happens to the emulated baseband

00:25:31.120 --> 00:25:34.600
 if we send benign input, which conforms to spec.

00:25:34.600 --> 00:25:37.400
 But what happens if we don't do so?

00:25:37.400 --> 00:25:40.920
 So what do you want to do if you want to send something that

00:25:40.920 --> 00:25:46.120
 doesn't conform with the thing that something wants to receive?

00:25:46.120 --> 00:25:47.520
 You use fuzzing these days.

00:25:47.520 --> 00:25:50.920
 Everybody probably, or most people would have heard about fuzzing.

00:25:50.920 --> 00:25:55.560
 It's basically throwing tons of input in a somewhat smart way

00:25:55.560 --> 00:25:59.160
 into a target until you find some side conditions

00:25:59.160 --> 00:26:02.960
 that the original author of the thing didn't think about.

00:26:02.960 --> 00:26:05.680
 You want to find something like an off by one

00:26:05.680 --> 00:26:09.880
 or some unchecked something where if you just read it,

00:26:09.880 --> 00:26:12.280
 maybe it's too much code and you will never find this.

00:26:12.280 --> 00:26:16.480
 But if you just randomly throw stuff at it, you'll find it.

00:26:16.480 --> 00:26:19.120
 And how do we do fuzzing in firmware?

00:26:19.120 --> 00:26:22.880
 Well, it is-- so we can do normal AFL++ fuzzing basically.

00:26:22.880 --> 00:26:25.640
 But we do it against a full system emulated baseband,

00:26:25.640 --> 00:26:26.920
 which is kind of cool.

00:26:26.920 --> 00:26:28.400
 For this, we have another task.

00:26:28.400 --> 00:26:30.080
 So we had the glink task earlier where

00:26:30.080 --> 00:26:33.360
 you can type things in Python and interact with the baseband.

00:26:33.360 --> 00:26:35.480
 But of course, this is slow.

00:26:35.480 --> 00:26:40.400
 For fuzzing, we injected a fuzz task using our modkit.

00:26:40.400 --> 00:26:44.720
 It then will send messages around that

00:26:44.720 --> 00:26:46.000
 come directly from the fuzzer.

00:26:46.000 --> 00:26:48.400
 So basically, it eats something from the fuzzer

00:26:48.400 --> 00:26:52.400
 and then sends it to some task that we want to take a look at.

00:26:52.400 --> 00:26:55.600
 And we have custom hypercalls to get this work.

00:26:55.600 --> 00:26:58.440
 So to get a new fuzzing message, the hypercalls

00:26:58.440 --> 00:27:01.040
 will also turn on coverage collection.

00:27:01.040 --> 00:27:04.720
 So the fuzzer will know if it found new branches

00:27:04.720 --> 00:27:06.200
 in the target task.

00:27:06.200 --> 00:27:09.040
 And for coverage collection, we had to hack QEMU a bit.

00:27:09.040 --> 00:27:12.560
 And we injected basically this on the TCG level.

00:27:12.560 --> 00:27:15.440
 If you know how QEMU works, it lifts every single--

00:27:15.440 --> 00:27:18.440
 so during runtime, it lifts every block

00:27:18.440 --> 00:27:21.080
 it hasn't yet seen into its intermediate language

00:27:21.080 --> 00:27:23.360
 and then compiles it back down or whatever,

00:27:23.360 --> 00:27:26.520
 emits it back down into the target architecture.

00:27:26.520 --> 00:27:29.360
 And when we have this lifted block in our hands,

00:27:29.360 --> 00:27:31.320
 it's basically all of the code.

00:27:31.320 --> 00:27:34.440
 And it's not one basic block, but it's one translation block.

00:27:34.440 --> 00:27:36.440
 So it's one code unit.

00:27:36.440 --> 00:27:40.520
 And we can use this to basically give feedback to the fuzzer

00:27:40.520 --> 00:27:41.720
 that we found something new.

00:27:41.720 --> 00:27:44.480
 So we jumped from some place to some new place.

00:27:44.480 --> 00:27:47.960
 And this edge will be reported back to the fuzzer

00:27:47.960 --> 00:27:50.720
 so that it can store input that found new coverage

00:27:50.720 --> 00:27:54.880
 and then do some mutations in a smarter way for the future.

00:27:54.880 --> 00:27:58.120
 And then we send the message that we received

00:27:58.120 --> 00:28:02.840
 from the smart mutation to this basement task internally.

00:28:02.840 --> 00:28:05.280
 For this, we also created multiple proof concept harnesses

00:28:05.280 --> 00:28:08.680
 else we wouldn't have found bugs, which would have been sad.

00:28:08.680 --> 00:28:11.360
 So let's put this a little bit more into practice

00:28:11.360 --> 00:28:13.720
 and look into how would we write our own harness

00:28:13.720 --> 00:28:16.520
 or our own fast task for a protocol of our choice.

00:28:16.520 --> 00:28:19.680
 In this example, we will basically walk slowly

00:28:19.680 --> 00:28:21.680
 through our CC fuzzer.

00:28:21.680 --> 00:28:23.520
 And for creating your own harness,

00:28:23.520 --> 00:28:25.520
 so call control, what we just saw before,

00:28:25.520 --> 00:28:26.840
 and for creating our harness,

00:28:26.840 --> 00:28:30.600
 one would first to create a new mod for the mod kit,

00:28:30.600 --> 00:28:33.880
 set up the fuzzer using a special fast single setup function

00:28:33.880 --> 00:28:35.880
 and specify what needs to be done

00:28:35.880 --> 00:28:37.600
 during each fuzzing iteration.

00:28:37.600 --> 00:28:42.560
 So for each fuzzing test case, we get out of AFL++.

00:28:42.560 --> 00:28:44.920
 So creating a new mod is kind of straight forward

00:28:44.920 --> 00:28:47.520
 on the one side, you will need the template

00:28:47.520 --> 00:28:50.400
 in this case for GSMCC just using some includes

00:28:50.400 --> 00:28:51.840
 and setting a task name.

00:28:51.840 --> 00:28:53.800
 And then we need to adjust the make file

00:28:53.800 --> 00:28:57.520
 to basically add the CC fuzzer in there.

00:28:57.520 --> 00:29:00.960
 So that will be compiled as mod, which then gets injected

00:29:00.960 --> 00:29:01.800
 during boot time.

00:29:01.800 --> 00:29:04.680
 - So CC again was call control.

00:29:04.680 --> 00:29:08.720
 So this is actually the fuzzer that will fuzz this call setup

00:29:08.720 --> 00:29:10.120
 that we saw earlier.

00:29:10.120 --> 00:29:11.200
 - Exactly.

00:29:11.200 --> 00:29:13.480
 And what's the fuzzing that setup does

00:29:13.480 --> 00:29:16.240
 is sending the init messages we just saw before

00:29:16.240 --> 00:29:17.080
 in the demo, right?

00:29:17.080 --> 00:29:21.280
 Like recall that basically the task at boot stage

00:29:21.280 --> 00:29:23.600
 is not ready yet to receive over the input.

00:29:23.600 --> 00:29:26.120
 So we need to send one magical reverse engineered message

00:29:26.120 --> 00:29:27.920
 before, which is what we're doing here

00:29:27.920 --> 00:29:30.880
 with the fuzzing setup function.

00:29:30.880 --> 00:29:34.840
 First we get the QID for CC, then we allocate a block

00:29:34.840 --> 00:29:37.080
 using the par mem alloc function.

00:29:37.080 --> 00:29:40.680
 So this is recovered via pattern DB from the mod kit,

00:29:40.680 --> 00:29:44.720
 via pattern DB and called from the injected task directly

00:29:44.720 --> 00:29:47.720
 in the firm, yeah, in the basement firmware.

00:29:47.720 --> 00:29:50.800
 And then we set up like once we have the block,

00:29:50.800 --> 00:29:51.960
 we set up the message.

00:29:51.960 --> 00:29:56.440
 So we basically set the op, we set the message group

00:29:56.440 --> 00:29:58.960
 and so on, and then use Paul message sent to,

00:29:58.960 --> 00:30:03.280
 to send this message we just created to the CC task.

00:30:03.280 --> 00:30:04.120
 Easy.

00:30:04.120 --> 00:30:07.880
 Now this would be received and the CC task would be ready.

00:30:07.880 --> 00:30:10.480
 So we can continue and specify what needs to be done

00:30:10.480 --> 00:30:12.040
 in a fuzzing iteration.

00:30:12.040 --> 00:30:14.560
 Here again, we start with getting a small block

00:30:14.560 --> 00:30:17.440
 from the basement was using par mem alloc.

00:30:17.440 --> 00:30:19.840
 And this time we will need some space

00:30:19.840 --> 00:30:21.480
 for the fuzzing input we get.

00:30:21.480 --> 00:30:24.280
 So we just say, okay, let's leave some space

00:30:24.280 --> 00:30:26.880
 for whatever AFL wants to give us.

00:30:26.880 --> 00:30:28.720
 And then we call get work.

00:30:28.720 --> 00:30:30.400
 Get work is one of our hyper calls,

00:30:30.400 --> 00:30:34.200
 which we use to communicate between Panda or FirmWire

00:30:34.200 --> 00:30:35.960
 and the fuzzer and get work.

00:30:35.960 --> 00:30:39.960
 We'll just get an input, write it into this shared buffer

00:30:39.960 --> 00:30:41.560
 and reports back to the input size

00:30:41.560 --> 00:30:43.120
 and the input size variable.

00:30:43.120 --> 00:30:44.800
 Now that we have our fuzzing input,

00:30:44.800 --> 00:30:47.680
 we need to continue and give it somehow

00:30:47.680 --> 00:30:49.720
 to the target task, to the CC task.

00:30:49.720 --> 00:30:53.920
 Before doing so, we set again up how the message looked like,

00:30:53.920 --> 00:30:56.160
 like we set the different header fields and so on.

00:30:56.160 --> 00:31:00.600
 And then copy over the payload we just got from the fuzzer

00:31:00.600 --> 00:31:03.320
 into the message so that we can send it.

00:31:03.320 --> 00:31:05.120
 And this is what we do.

00:31:05.120 --> 00:31:07.680
 First we do call start work, another hyper call,

00:31:07.680 --> 00:31:10.280
 which will enable the coverage collection

00:31:10.280 --> 00:31:11.760
 Dominic just explained.

00:31:11.760 --> 00:31:15.000
 In this case, we want to collect coverage from address zero

00:31:15.000 --> 00:31:18.200
 to address 0xFFFFFFFF,

00:31:18.200 --> 00:31:21.400
 which is basically all of the memory in a 32-bit space.

00:31:21.400 --> 00:31:23.440
 So we want to collect all coverage.

00:31:23.440 --> 00:31:25.800
 And then we call ParalMessageSendTo again

00:31:25.800 --> 00:31:28.480
 to send it over to the target task.

00:31:28.480 --> 00:31:33.160
 And one thing to note here is that we modify our,

00:31:33.160 --> 00:31:36.360
 or we compile our further tasks

00:31:36.360 --> 00:31:38.880
 to have a very low priority in the operating system.

00:31:38.880 --> 00:31:41.000
 So when we call ParalMessageSendTo,

00:31:41.000 --> 00:31:43.400
 it will actually, or the scheduler will actually schedule

00:31:43.400 --> 00:31:46.040
 our task out and send it to the CC task,

00:31:46.040 --> 00:31:47.600
 which has a higher priority.

00:31:47.600 --> 00:31:49.680
 So this call would basically block,

00:31:49.680 --> 00:31:52.840
 and we only return to our fuzzing task

00:31:52.840 --> 00:31:55.120
 once the CC message was processed.

00:31:55.120 --> 00:31:57.360
 And once we are back, we call done work,

00:31:57.360 --> 00:31:59.280
 another hyper call which basically says

00:31:59.280 --> 00:32:01.800
 stop coverage collection, we are done here for now,

00:32:01.800 --> 00:32:05.280
 and we can start again in the next fuzzing iteration.

00:32:05.280 --> 00:32:08.120
 - Right, cool, so let's see some fuzzing in action.

00:32:08.120 --> 00:32:10.800
 And what we're gonna do now is, so I'm gonna show,

00:32:10.800 --> 00:32:12.200
 this is probably gonna be--

00:32:12.200 --> 00:32:13.240
 - Let's see. - Let's see.

00:32:13.240 --> 00:32:14.360
 This may be broken.

00:32:15.880 --> 00:32:18.920
 - Well, you know, you think command line tools

00:32:18.920 --> 00:32:21.040
 would just work, but you know, it's not perfect.

00:32:21.040 --> 00:32:23.720
 - Okay, so, yep, well, we can.

00:32:23.720 --> 00:32:28.320
 - Anyway, so what you should see

00:32:28.320 --> 00:32:31.800
 is basically a normal AFL++ command line,

00:32:31.800 --> 00:32:36.040
 and then you should see, can you switch back anyway?

00:32:36.040 --> 00:32:36.880
 - Okay.

00:32:36.880 --> 00:32:39.480
 - Yeah, we give it basically the fuzz task,

00:32:39.480 --> 00:32:42.580
 so the task that we wanna inject,

00:32:42.580 --> 00:32:44.920
 when we give it a snapshot,

00:32:44.920 --> 00:32:47.000
 that we also wanna load from,

00:32:47.000 --> 00:32:49.720
 and then we give it add, add for, you know,

00:32:49.720 --> 00:32:51.760
 add, add, yeah, that's the add, add,

00:32:51.760 --> 00:32:55.440
 for, which is, if people have used AFL++ before,

00:32:55.440 --> 00:32:58.120
 it's the basic command line that tells the fuzzer,

00:32:58.120 --> 00:33:00.040
 give me input to this place.

00:33:00.040 --> 00:33:02.000
 Like under the hood, we actually get the input

00:33:02.000 --> 00:33:04.800
 via shared memory from the fuzzer, but it doesn't matter.

00:33:04.800 --> 00:33:07.960
 And then we're gonna start AFL++.

00:33:07.960 --> 00:33:10.320
 This is without persistent mode,

00:33:10.320 --> 00:33:13.200
 so that means that after every execution,

00:33:13.200 --> 00:33:17.240
 the target quits, and then we restart the target,

00:33:17.240 --> 00:33:19.880
 or we refork the target, so that's why it's pretty slow,

00:33:19.880 --> 00:33:21.660
 but the stability is 100%.

00:33:21.660 --> 00:33:23.120
 We can also use persistent mode,

00:33:23.120 --> 00:33:26.380
 which will make the fuzz task basically just loop around

00:33:26.380 --> 00:33:28.000
 and ask the fuzzer for the next input,

00:33:28.000 --> 00:33:31.200
 and then we get up to like almost 2,000 execs

00:33:31.200 --> 00:33:33.880
 on a single core, which is decently fast,

00:33:33.880 --> 00:33:36.340
 but of course then other tasks in the baseband

00:33:36.340 --> 00:33:39.080
 may jump in at some time, so it's not as stable,

00:33:39.080 --> 00:33:41.800
 but of course it's a pretty good trade-off.

00:33:41.800 --> 00:33:44.640
 So yeah, so fuzzing works, woo.

00:33:44.640 --> 00:33:47.640
 And then-- (audience applauds)

00:33:47.640 --> 00:33:52.960
 If you leave this guy running for a short while,

00:33:52.960 --> 00:33:56.960
 actually, you can also find crashes.

00:33:56.960 --> 00:34:01.080
 So the CC task found one critical bug

00:34:01.080 --> 00:34:03.780
 that was zero day at the time.

00:34:03.780 --> 00:34:06.660
 We also looked into LTE RRC,

00:34:06.660 --> 00:34:08.900
 which is another pre-authentication message,

00:34:08.900 --> 00:34:11.480
 but in the LTE, so in 4G,

00:34:11.480 --> 00:34:13.040
 where we also found two critical

00:34:13.040 --> 00:34:14.920
 and one high rated zero day,

00:34:14.920 --> 00:34:18.040
 and then we used SM, which is another task

00:34:18.040 --> 00:34:21.120
 that has been explored in the past, as a ground truth.

00:34:21.120 --> 00:34:23.560
 So in total, we had seven crashes

00:34:23.560 --> 00:34:25.320
 deduplicated over all of our fuzzing,

00:34:25.320 --> 00:34:28.700
 and four of them were unknown at this point in time.

00:34:28.700 --> 00:34:30.320
 - And we reported them to the window.

00:34:30.320 --> 00:34:31.840
 - Yes, they're all fixed by now.

00:34:31.840 --> 00:34:33.660
 - Yeah, but exactly.

00:34:33.660 --> 00:34:36.560
 So let's do the next demo and just look

00:34:36.560 --> 00:34:38.520
 in how it looks like if we would replay

00:34:38.520 --> 00:34:40.020
 such a crash we found.

00:34:40.700 --> 00:34:45.700
 Right, so we're gonna start firmware wire again,

00:34:45.700 --> 00:34:48.860
 and we're gonna restore the same snapshot

00:34:48.860 --> 00:34:51.340
 that you would have seen in the last demo.

00:34:51.340 --> 00:34:53.540
 And then we use the fuzz triage mode,

00:34:53.540 --> 00:34:56.500
 which is like fuzzing, but it has more logging enabled,

00:34:56.500 --> 00:34:58.580
 like we usually disable logging during fuzzing

00:34:58.580 --> 00:34:59.980
 because it's slow.

00:34:59.980 --> 00:35:02.540
 And then we give it the input that the fuzzer found.

00:35:02.540 --> 00:35:06.500
 So the fuzzer conveniently named it crash.bin,

00:35:06.500 --> 00:35:09.260
 and then we ran it against the same modem bin

00:35:09.260 --> 00:35:11.540
 we renamed to vulnmodem in this case.

00:35:11.540 --> 00:35:14.780
 And then you see in the end that there's a prefetch abort,

00:35:14.780 --> 00:35:16.860
 so it's faulting at a PC.

00:35:16.860 --> 00:35:20.340
 It tries to fetch a PC that doesn't have executable code,

00:35:20.340 --> 00:35:22.860
 which is usually a good, like a bad sign

00:35:22.860 --> 00:35:24.740
 from security perspective or a good,

00:35:24.740 --> 00:35:27.500
 if you wanna find bugs that may be exploitable.

00:35:27.500 --> 00:35:30.300
 - Fathers will like it, developers not so much.

00:35:30.300 --> 00:35:31.140
 - Yes.

00:35:31.140 --> 00:35:34.220
 - Okay, cool.

00:35:34.220 --> 00:35:38.600
 - And this, so to show that these crashes actually work,

00:35:38.600 --> 00:35:40.880
 we also replayed them over the air.

00:35:40.880 --> 00:35:45.480
 So we used some BTSs for GSM, we used Yate.

00:35:45.480 --> 00:35:47.500
 For LTE RSC, we used OpenLTE.

00:35:47.500 --> 00:35:49.900
 So you can talk to a little SDR,

00:35:49.900 --> 00:35:52.360
 and the SDR will then send our input,

00:35:52.360 --> 00:35:54.500
 like we patched them to send our inputs

00:35:54.500 --> 00:35:57.220
 that we found that are crashing.

00:35:57.220 --> 00:36:01.920
 And then actually all of these pre-authentication messages

00:36:01.920 --> 00:36:04.900
 also caused a crash in the actual modem.

00:36:04.900 --> 00:36:07.240
 So you see down here, real restart,

00:36:07.240 --> 00:36:10.060
 which means the radio layer just died

00:36:10.060 --> 00:36:11.620
 and I'm gonna restart it.

00:36:11.620 --> 00:36:14.820
 So which is, I mean, this is probably the good case

00:36:14.820 --> 00:36:17.300
 because this means that it just crashed and restarted,

00:36:17.300 --> 00:36:19.780
 which is better than other things that,

00:36:19.780 --> 00:36:21.940
 there's no code being run in this case.

00:36:21.940 --> 00:36:23.820
 - Yeah, and I mean, that's all what it means

00:36:23.820 --> 00:36:25.340
 to crash a baseband in that sense.

00:36:25.340 --> 00:36:27.780
 It's not that the phone dies and reboots,

00:36:27.780 --> 00:36:30.420
 it's just the connectivity symbol on the top right

00:36:30.420 --> 00:36:32.580
 will disappear, come back, you will get a little pop-up

00:36:32.580 --> 00:36:34.020
 in the best case.

00:36:34.020 --> 00:36:36.660
 But from the attacker's view, they could go from there

00:36:36.660 --> 00:36:39.140
 and probably exploit the baseband and yeah,

00:36:39.140 --> 00:36:40.860
 take it from there.

00:36:40.860 --> 00:36:43.660
 And we were not interested in that.

00:36:43.660 --> 00:36:46.180
 Instead, we were looking more into the different bugs

00:36:46.180 --> 00:36:49.060
 we have in a large scale context.

00:36:49.060 --> 00:36:52.540
 So we collected a lot of different firmwares and--

00:36:52.540 --> 00:36:53.660
 - Oops, sorry.

00:36:53.660 --> 00:36:57.380
 - Yep, and the idea is we have some ground truth crashing

00:36:57.380 --> 00:37:00.780
 or some crashes which work on the modem refast.

00:37:00.780 --> 00:37:02.620
 How does it look in the full ecosystem?

00:37:02.620 --> 00:37:05.820
 So if we take other modem images and replay the same crashes,

00:37:05.820 --> 00:37:06.740
 what would happen?

00:37:06.740 --> 00:37:08.980
 So with intuition, we could get insights

00:37:08.980 --> 00:37:11.860
 about patching timelines and similar.

00:37:11.860 --> 00:37:14.820
 And we collected for this like, I think,

00:37:14.820 --> 00:37:18.500
 over 200 different firmware images from Mirror,

00:37:18.500 --> 00:37:20.460
 which has the full Android update

00:37:20.460 --> 00:37:23.680
 and extracted the baseband modem image file from there.

00:37:23.680 --> 00:37:29.460
 - Right, and overall, we collected 360 firmwares

00:37:29.460 --> 00:37:32.780
 from between 2016 and 2021.

00:37:33.840 --> 00:37:36.020
 Of these, 131s were duplicates.

00:37:36.020 --> 00:37:38.600
 So we downloaded a new Android image,

00:37:38.600 --> 00:37:41.100
 but it didn't have an update on the modem image,

00:37:41.100 --> 00:37:43.140
 which happens, they don't update the modem

00:37:43.140 --> 00:37:45.220
 as often as the main operating system.

00:37:45.220 --> 00:37:49.560
 And then of these, we were able to boot 213.

00:37:49.560 --> 00:37:51.220
 So 16 of them failed to boot.

00:37:51.220 --> 00:37:52.460
 And in the large scale study,

00:37:52.460 --> 00:37:54.340
 you don't really wanna look into everything.

00:37:54.340 --> 00:37:56.540
 So probably they just like,

00:37:56.540 --> 00:37:59.340
 hanged in something waiting for some data

00:37:59.340 --> 00:38:02.460
 that we didn't provide in the right way in this case.

00:38:02.460 --> 00:38:04.180
 - So, and these are the models that we looked at.

00:38:04.180 --> 00:38:08.180
 So a lot of Samsungs, S7 to S10,

00:38:08.180 --> 00:38:11.180
 and then A41 and A10s.

00:38:11.180 --> 00:38:13.080
 - So these are also Samsung phones,

00:38:13.080 --> 00:38:14.740
 but using a MediaTek baseband chip.

00:38:14.740 --> 00:38:15.580
 - Yeah, yeah, yeah.

00:38:15.580 --> 00:38:17.900
 As well.

00:38:17.900 --> 00:38:22.140
 And then on Synodo, you can find actually the whole dataset

00:38:22.140 --> 00:38:25.020
 if you're interested and wanna replicate our study.

00:38:25.020 --> 00:38:27.180
 - Exactly, and here are our results.

00:38:27.180 --> 00:38:29.220
 - Look at our study again, I guess.

00:38:29.220 --> 00:38:31.460
 - Anyhow, here are our results, and don't be afraid.

00:38:31.460 --> 00:38:34.220
 This figure is overly convoluted and complicated,

00:38:34.220 --> 00:38:35.780
 but we will walk you through it.

00:38:35.780 --> 00:38:39.940
 So first of all, each dot in here is one firmware image,

00:38:39.940 --> 00:38:41.340
 which we downloaded.

00:38:41.340 --> 00:38:43.860
 And on the bottom, we have the timeline.

00:38:43.860 --> 00:38:46.260
 So this is firmware images over time.

00:38:46.260 --> 00:38:48.340
 And on the left, we split up

00:38:48.340 --> 00:38:50.140
 for the different phone models we tested.

00:38:50.140 --> 00:38:53.820
 And this graphic is just Shannon-based ones.

00:38:53.820 --> 00:38:57.420
 And these here are the different crashing inputs, right?

00:38:57.420 --> 00:38:59.460
 So the ones we found during fuzzing.

00:38:59.460 --> 00:39:04.340
 And in this figure, we see when there is a green background

00:39:04.340 --> 00:39:06.840
 behind the dot, it means there was no crash

00:39:06.840 --> 00:39:09.380
 or we didn't observe a crash when replaying the crash.

00:39:09.380 --> 00:39:11.460
 When it was a red background, it is,

00:39:11.460 --> 00:39:13.020
 we saw a crash happening.

00:39:13.020 --> 00:39:15.000
 And the grayed out ones is, okay,

00:39:15.000 --> 00:39:17.620
 we had some emulation errors or couldn't access

00:39:17.620 --> 00:39:19.180
 whether there was a crash.

00:39:19.180 --> 00:39:21.340
 But as we were large scale, we just didn't care.

00:39:21.340 --> 00:39:24.420
 We just looked into what does crash, what does not crash.

00:39:24.420 --> 00:39:27.300
 And I think there are a couple of interesting things to see.

00:39:27.300 --> 00:39:31.420
 First of all, the SM bug we used as ground truth testing.

00:39:31.420 --> 00:39:36.100
 We, yeah, we basically saw that it was indeed patched

00:39:36.100 --> 00:39:38.900
 for good, it never came back later on any phone

00:39:38.900 --> 00:39:41.460
 after it was initially patched.

00:39:41.460 --> 00:39:45.340
 The TCE1 crash we found really affected all the phones.

00:39:45.340 --> 00:39:47.860
 So it was indeed quite a critical vulnerability.

00:39:47.860 --> 00:39:49.980
 And we also happily see that it was patched

00:39:49.980 --> 00:39:51.340
 and didn't knock you again.

00:39:51.340 --> 00:39:56.660
 For IRC bugs, we see that they are not affecting all bugs.

00:39:56.660 --> 00:39:58.780
 So they are not all phones, sorry.

00:39:58.780 --> 00:40:00.540
 So there are quite some differences,

00:40:00.540 --> 00:40:03.040
 which I think is also quite interesting.

00:40:03.040 --> 00:40:07.580
 And we also see, which I think is one real good outcome

00:40:07.580 --> 00:40:09.020
 of this large scale study,

00:40:09.020 --> 00:40:11.820
 that sometimes there's missing patch propagation, right?

00:40:11.820 --> 00:40:15.500
 We found this IRC1 bug on the STNE in the father,

00:40:15.500 --> 00:40:16.860
 we reported it.

00:40:16.860 --> 00:40:19.400
 And only one year later, we did the large scale analysis

00:40:19.400 --> 00:40:21.620
 and we saw, oh no, on another phone,

00:40:21.620 --> 00:40:23.700
 this bug is actually still active and not patched.

00:40:23.700 --> 00:40:25.300
 So we went again and reported it

00:40:25.300 --> 00:40:27.900
 and got it fixed in the very end eventually.

00:40:27.900 --> 00:40:31.640
 So yeah, these are some interesting insights,

00:40:31.640 --> 00:40:33.060
 but let's wrap up the talk.

00:40:33.060 --> 00:40:36.780
 - Yeah, thank you all for your time.

00:40:36.780 --> 00:40:39.420
 So we, as said in the beginning,

00:40:39.420 --> 00:40:41.820
 we built the first public

00:40:41.820 --> 00:40:44.100
 full system baseband emulation platform.

00:40:44.100 --> 00:40:45.860
 We have cool introspection stuff

00:40:45.860 --> 00:40:47.680
 and instrumentation capabilities that you looked at,

00:40:47.680 --> 00:40:50.980
 including like fuzzing and looking around in a baseband.

00:40:50.980 --> 00:40:54.340
 We have support for MTK and Shannon from back then.

00:40:54.340 --> 00:40:58.100
 We found multiple bugs and there's probably a lot more.

00:40:58.100 --> 00:41:01.740
 So we basically writing a fuzz task is a manual effort.

00:41:01.740 --> 00:41:05.280
 You have to reverse a ton and then build your task.

00:41:05.280 --> 00:41:09.680
 And there's probably a lot more if you wanna look at it.

00:41:09.680 --> 00:41:11.980
 You can go check out our source code

00:41:11.980 --> 00:41:14.860
 on firmware slash firmware on GitHub.

00:41:14.860 --> 00:41:16.020
 We have, you know, it's Docker,

00:41:16.020 --> 00:41:17.660
 so you can easily set it up.

00:41:17.660 --> 00:41:19.180
 And we have documentation,

00:41:19.180 --> 00:41:21.980
 which is a big plus for open source project, I think.

00:41:21.980 --> 00:41:24.980
 (audience applauds)

00:41:24.980 --> 00:41:31.860
 And with that, we wanna conclude our talk.

00:41:31.860 --> 00:41:35.440
 You can reach us via email and you can go to our repo

00:41:35.440 --> 00:41:37.940
 and ask questions starting now.

00:41:37.940 --> 00:41:38.780
 Thank you so much.

00:41:38.780 --> 00:41:41.780
 (audience applauds)

00:41:41.780 --> 00:41:50.900
 - You mentioned Cortex-A already

00:41:50.900 --> 00:41:52.420
 as an application processor

00:41:52.420 --> 00:41:54.420
 on top of the application process.

00:41:54.420 --> 00:41:57.760
 Are there any plans to add support for the Cortex-A?

00:41:57.760 --> 00:42:00.340
 - Plans, yes.

00:42:00.340 --> 00:42:01.320
 Time, no.

00:42:01.320 --> 00:42:04.100
 - Yeah. - PR's welcome.

00:42:04.100 --> 00:42:06.480
 - Yeah, we are basically typing back to this

00:42:06.480 --> 00:42:08.300
 every half a year, doing a little bit more,

00:42:08.300 --> 00:42:12.580
 but never, by now just in the state of a hobby project

00:42:12.580 --> 00:42:15.100
 for us, we, yeah.

00:42:15.100 --> 00:42:18.180
 But that being said, we welcome contributions.

00:42:18.180 --> 00:42:19.460
 So there's still-- - We tried.

00:42:19.460 --> 00:42:20.380
 That's why I asked.

00:42:20.380 --> 00:42:22.300
 - Yeah, okay, I mean, we can think

00:42:22.300 --> 00:42:23.940
 and try to make it happen, right?

00:42:23.940 --> 00:42:27.920
 - And second question, don't know if it's allowed.

00:42:27.920 --> 00:42:30.620
 How did you get started on this?

00:42:30.620 --> 00:42:32.340
 Did you first read the specs?

00:42:32.340 --> 00:42:34.260
 Did you first try to reverse?

00:42:34.260 --> 00:42:35.260
 Did you--

00:42:35.260 --> 00:42:37.660
 - For me, it was first starting the reverse engineering.

00:42:37.660 --> 00:42:38.800
 - Same. - Yeah.

00:42:38.800 --> 00:42:40.260
 - Yeah, I have no idea about specs.

00:42:40.260 --> 00:42:43.500
 - I learned specs during looking at binary inputs.

00:42:43.500 --> 00:42:45.020
 I think that's-- - So did somebody else

00:42:45.020 --> 00:42:48.300
 on the team have a lot of time to read the specs or--

00:42:48.300 --> 00:42:50.360
 - Yes, in the end, we had some people in the team

00:42:50.360 --> 00:42:54.020
 which were really knowledgeable about the specs,

00:42:54.020 --> 00:42:55.100
 and also when we were stuck,

00:42:55.100 --> 00:42:56.300
 we were looking at things together,

00:42:56.300 --> 00:42:58.380
 and then they can just up with,

00:42:58.380 --> 00:42:59.860
 oh, hey, that could be this and this

00:42:59.860 --> 00:43:01.580
 according to that and that spec.

00:43:01.580 --> 00:43:05.100
 - I mean, and the main question, which is interesting

00:43:05.100 --> 00:43:06.740
 and can only be solved by looking at the spec

00:43:06.740 --> 00:43:10.140
 is which tasks are actually accessible over the air,

00:43:10.140 --> 00:43:11.100
 without authentication,

00:43:11.100 --> 00:43:13.060
 or which are more critical than others.

00:43:13.060 --> 00:43:16.220
 For this, you need some knowledge about spec specification.

00:43:16.220 --> 00:43:18.220
 - Thank you.

00:43:18.800 --> 00:43:21.720
 (air whooshing)

00:43:21.720 --> 00:43:22.880
 - Thanks for the talk.

00:43:22.880 --> 00:43:26.880
 I'd love to have some insights about how much time

00:43:26.880 --> 00:43:29.240
 and effort went into all of this work.

00:43:29.240 --> 00:43:32.360
 How many years have you all been working on this?

00:43:32.360 --> 00:43:34.040
 (laughing)

00:43:34.040 --> 00:43:34.880
 - Yes.

00:43:34.880 --> 00:43:36.680
 (laughing)

00:43:36.680 --> 00:43:40.840
 So I think I, so Grant, I think started working

00:43:40.840 --> 00:43:45.840
 on this mid-2019, and I joined in around winter 2019.

00:43:47.200 --> 00:43:51.200
 And then it took, I think, until early 2022,

00:43:51.200 --> 00:43:53.440
 before we had the public release of the tool.

00:43:53.440 --> 00:43:57.880
 By, I say 2020, I think we had a proof of concept

00:43:57.880 --> 00:43:59.960
 kind of working, only for Shannon, very rough,

00:43:59.960 --> 00:44:02.280
 but at least it was running and emulating, which was cool,

00:44:02.280 --> 00:44:04.720
 and I think the main milestone.

00:44:04.720 --> 00:44:06.640
 But then, yeah, fuzzing and increasing on this

00:44:06.640 --> 00:44:08.040
 took also considerable amount of time.

00:44:08.040 --> 00:44:10.440
 - And then I started also looking independently

00:44:10.440 --> 00:44:13.760
 into media tech stuff in 2019 as well, or '18 even,

00:44:13.760 --> 00:44:17.540
 so it definitely, there was some way to go.

00:44:17.540 --> 00:44:20.800
 Don't start this from scratch, I guess, but.

00:44:20.800 --> 00:44:22.320
 (laughing)

00:44:22.320 --> 00:44:24.560
 I mean, by now there are probably also

00:44:24.560 --> 00:44:28.080
 like better full system emulation tools around

00:44:28.080 --> 00:44:30.660
 that may make it easier to, you know,

00:44:30.660 --> 00:44:32.480
 like all of the fuzzing stuff, at least,

00:44:32.480 --> 00:44:34.360
 is kind of solved now.

00:44:34.360 --> 00:44:37.600
 - And also, yeah, for perspective, early 2022,

00:44:37.600 --> 00:44:40.000
 we released the framework, and just yesterday,

00:44:40.000 --> 00:44:42.600
 we pushed version, we 1.1.0.

00:44:42.600 --> 00:44:43.440
 - Woo!

00:44:43.440 --> 00:44:46.600
 (audience applauding)

00:44:46.600 --> 00:44:54.720
 - Thank you for the talk.

00:44:54.720 --> 00:44:56.880
 Could you tell us sort of roughly

00:44:56.880 --> 00:44:59.480
 what typical firmware security looks like

00:44:59.480 --> 00:45:00.900
 on these baseband processors?

00:45:00.900 --> 00:45:03.100
 Like, you mentioned encrypted firmware,

00:45:03.100 --> 00:45:05.920
 but I imagine there's signatures and things of this sort.

00:45:05.920 --> 00:45:09.000
 - So yes, some vendors do encrypt the firmware.

00:45:09.000 --> 00:45:11.920
 Almost all vendors sign the firmware

00:45:11.920 --> 00:45:14.080
 so that you cannot just modify it and so on.

00:45:14.080 --> 00:45:15.960
 But beyond this, runtime defenses are--

00:45:15.960 --> 00:45:18.360
 - I don't, by the way, I don't think encryption

00:45:18.360 --> 00:45:20.960
 would be a security feature, right, but it's just me.

00:45:20.960 --> 00:45:23.200
 - Yeah.

00:45:23.200 --> 00:45:26.840
 So signature checking for preventing you

00:45:26.840 --> 00:45:28.400
 from running your own baseband firmware,

00:45:28.400 --> 00:45:31.080
 which I guess makes sense.

00:45:31.080 --> 00:45:34.680
 And then runtime security protections are,

00:45:34.680 --> 00:45:36.280
 I would say, a bit lacking behind

00:45:36.280 --> 00:45:37.480
 for what we know from desktops.

00:45:37.480 --> 00:45:38.960
 We have basically no ASLR.

00:45:38.960 --> 00:45:40.240
 (laughing)

00:45:40.240 --> 00:45:44.400
 Like, we have some sort of heap cookies,

00:45:44.400 --> 00:45:47.640
 which are, in the Shannon example,

00:45:47.640 --> 00:45:49.600
 which were just one static string,

00:45:49.600 --> 00:45:52.800
 similar with Airtos stack, so not function stack cookies,

00:45:52.800 --> 00:45:54.200
 but cookies for the full stack,

00:45:54.200 --> 00:45:56.360
 which were static initialized to one value.

00:45:56.360 --> 00:45:59.340
 So it's a bit stuck in the past,

00:45:59.340 --> 00:46:02.000
 but I hear there are great efforts to improving it.

00:46:02.000 --> 00:46:05.280
 - Yeah, if you look at the Android Red Team talk

00:46:05.280 --> 00:46:08.040
 on BlackHat, you see that, you know,

00:46:08.040 --> 00:46:09.800
 at least on Pixel, they're working on

00:46:09.800 --> 00:46:11.400
 getting this improved.

00:46:11.400 --> 00:46:14.080
 But yeah, back when we looked into it,

00:46:14.080 --> 00:46:15.280
 there was basically none.

00:46:15.280 --> 00:46:24.520
 - How do you reverse engineer the format of the IPC?

00:46:24.520 --> 00:46:28.400
 Is that easy, or how do you go from a crash

00:46:28.400 --> 00:46:31.040
 to the actual radio message?

00:46:31.040 --> 00:46:32.580
 So you have the different tasks,

00:46:32.580 --> 00:46:36.480
 but do they actually just send the content

00:46:36.480 --> 00:46:39.280
 of the next layer to the corresponding task,

00:46:39.280 --> 00:46:41.440
 or is there something more complicated going on?

00:46:41.440 --> 00:46:44.860
 - Yeah, usually a task takes in a message,

00:46:44.860 --> 00:46:47.400
 does some unwrapping and maybe a little bit processing,

00:46:47.400 --> 00:46:50.040
 and then takes the rest, which needs to go more up

00:46:50.040 --> 00:46:51.640
 and sends us on up.

00:46:51.640 --> 00:46:54.040
 And it all uses, I mean, in most cases,

00:46:54.040 --> 00:46:56.540
 it uses the same, or at least very similar function

00:46:56.540 --> 00:46:58.240
 for doing the message sending.

00:46:58.240 --> 00:47:00.300
 And then for processing, you basically see

00:47:00.300 --> 00:47:01.520
 how this message is processed,

00:47:01.520 --> 00:47:05.040
 and you can use this to infer the C structure,

00:47:05.040 --> 00:47:07.000
 which this message should have had.

00:47:07.000 --> 00:47:09.080
 And once you created your types for that,

00:47:09.080 --> 00:47:11.120
 it gets all a little bit more easy to see.

00:47:11.120 --> 00:47:13.560
 - The task that we looked at were all accessible

00:47:13.560 --> 00:47:16.120
 over the air with bytes, so it was not that hard.

00:47:16.120 --> 00:47:19.000
 And they would forward it internally to other tasks

00:47:19.000 --> 00:47:22.120
 as well during fuzzing, because it's a full system framework,

00:47:22.120 --> 00:47:23.680
 so that makes it a bit easier.

00:47:23.680 --> 00:47:27.040
 But of course, if you look into an internal task,

00:47:27.040 --> 00:47:29.440
 and then you will have to craft some message

00:47:29.440 --> 00:47:33.820
 that would probably be more harder than what we did.

00:47:33.820 --> 00:47:34.740
 - Yeah, thank you.

00:47:37.600 --> 00:47:41.000
 Is there any work to extending this to other basebands,

00:47:41.000 --> 00:47:43.960
 like the Qualcomm or other vendors?

00:47:43.960 --> 00:47:45.120
 - Yeah, so with the Qualcomm,

00:47:45.120 --> 00:47:47.520
 there's one main roadblock at the moment

00:47:47.520 --> 00:47:49.200
 that Qualcomm basebands use

00:47:49.200 --> 00:47:51.400
 a custom instruction set architecture,

00:47:51.400 --> 00:47:54.280
 and the tooling for this is a bit lacking behind, right?

00:47:54.280 --> 00:47:56.680
 So without having a full system emulator

00:47:56.680 --> 00:47:58.500
 for Qualcomm basebands, we cannot,

00:47:58.500 --> 00:48:02.960
 not a full system emulator for hexagon in general,

00:48:02.960 --> 00:48:05.320
 we cannot build on top of it with our tooling.

00:48:06.720 --> 00:48:08.600
 The only thing you can do with Qualcomm right now

00:48:08.600 --> 00:48:13.600
 is use libfl-qemu to do basically a single task

00:48:13.600 --> 00:48:16.840
 in user mode qemu.

00:48:16.840 --> 00:48:20.000
 User mode qemu, there's a public implementation

00:48:20.000 --> 00:48:23.720
 in qemu upstream, and then libfl-qemu

00:48:23.720 --> 00:48:25.640
 can actually fuzz these single tasks,

00:48:25.640 --> 00:48:28.040
 but then of course you don't have all of the flashy

00:48:28.040 --> 00:48:30.540
 full system interaction between tasks and things.

00:48:34.320 --> 00:48:37.000
 - How do you interface with your simulated hardware?

00:48:37.000 --> 00:48:38.840
 Do you intercept the API calls

00:48:38.840 --> 00:48:41.280
 or emulate the register level access?

00:48:41.280 --> 00:48:45.160
 - We emulate the register level access, yeah.

00:48:45.160 --> 00:48:47.000
 And I mean, we stop a lot, right?

00:48:47.000 --> 00:48:50.040
 In some cases, like when peripherals need to initialize,

00:48:50.040 --> 00:48:51.560
 we don't really care what's going on.

00:48:51.560 --> 00:48:53.600
 Most of the time, the firmware will just check,

00:48:53.600 --> 00:48:56.160
 like it writes something, we discard it in our emulator,

00:48:56.160 --> 00:48:59.260
 and then it will check, is this bit set to one

00:48:59.260 --> 00:49:02.120
 which indicates that it was initialized?

00:49:02.120 --> 00:49:05.560
 So we are lazy and just created a cyclic bit peripheral

00:49:05.560 --> 00:49:08.440
 which on every read access would return another bit set,

00:49:08.440 --> 00:49:12.200
 and eventually, like once we had this simple approach,

00:49:12.200 --> 00:49:15.220
 we booted, I think, 90% of the different peripherals.

00:49:15.220 --> 00:49:18.240
 And yeah, some of course need a bit more work

00:49:18.240 --> 00:49:21.520
 and more reverse engineering, and specifically timers.

00:49:21.520 --> 00:49:23.920
 I still have nightmares about reverse engineering.

00:49:23.920 --> 00:49:31.000
 - From the demos, it looked like you always

00:49:31.000 --> 00:49:32.680
 use a specific snapshot.

00:49:32.680 --> 00:49:35.000
 Has there been like selection process

00:49:35.000 --> 00:49:37.480
 of selecting snapshots that you want to use?

00:49:37.480 --> 00:49:41.040
 And because it was perceived as runtime

00:49:41.040 --> 00:49:42.920
 and fuzzing on the runtime,

00:49:42.920 --> 00:49:46.920
 but did you prepare a specific snapshot?

00:49:46.920 --> 00:49:49.880
 - So the snapshot heuristic we used was quite simple.

00:49:49.880 --> 00:49:51.600
 We saw in the first demo that at some point,

00:49:51.600 --> 00:49:53.840
 it was looping and scheduling in the same task.

00:49:53.840 --> 00:49:56.520
 We took this address from the BTL task,

00:49:56.520 --> 00:49:58.440
 which was not important, but we saw this address

00:49:58.440 --> 00:49:59.640
 and just say, okay, here's a modem,

00:49:59.640 --> 00:50:00.740
 we'll expect things to happen,

00:50:00.740 --> 00:50:03.640
 so let's snapshot there, and yeah, we went from there.

00:50:03.640 --> 00:50:06.520
 - So it's mainly to skip over the initialization for this.

00:50:06.520 --> 00:50:09.880
 Like you could use snapshots deeper in the stack somewhere

00:50:09.880 --> 00:50:12.560
 where some side conditions have already been met,

00:50:12.560 --> 00:50:14.060
 but we didn't do that yet.

00:50:14.060 --> 00:50:16.480
 - Yeah, I was curious.

00:50:16.480 --> 00:50:17.960
 In the combination with fuzzing,

00:50:17.960 --> 00:50:19.800
 I mean, if you can proactively,

00:50:19.800 --> 00:50:21.640
 like you have discovered in your branch,

00:50:21.640 --> 00:50:22.760
 you make a snapshot, right?

00:50:22.760 --> 00:50:27.260
 It's a very powerful mechanism to just start from something

00:50:27.260 --> 00:50:29.080
 where you have done most of the work

00:50:29.080 --> 00:50:30.480
 and you're just looking.

00:50:30.480 --> 00:50:31.920
 And then you're saying like, okay,

00:50:31.920 --> 00:50:33.800
 this branch I want to get here

00:50:33.800 --> 00:50:36.520
 and set out the fuzzer to get towards the target

00:50:36.520 --> 00:50:37.920
 with solvers or something.

00:50:37.920 --> 00:50:39.600
 - Yeah, I mean, you could do this, right?

00:50:39.600 --> 00:50:41.560
 You could create a manual harness,

00:50:41.560 --> 00:50:44.680
 which first does this and then snapshot or, yeah.

00:50:44.680 --> 00:50:45.640
 Like you could automate it.

00:50:45.640 --> 00:50:47.120
 We haven't done it yet.

00:50:47.120 --> 00:50:48.360
 - Pandas is a good choice.

00:50:48.360 --> 00:50:53.480
 - Great, so we have so many questions.

00:50:53.480 --> 00:50:56.020
 Unfortunately, I have to give the last question now.

00:50:56.020 --> 00:50:57.960
 - Hi.

00:50:57.960 --> 00:51:01.760
 - The trick where you're like scheduling your fuzzing task

00:51:01.760 --> 00:51:03.760
 with a low priority is cool,

00:51:03.760 --> 00:51:06.800
 but did you run into cases where essentially

00:51:06.800 --> 00:51:09.800
 you're stopping too early or like the thing

00:51:09.800 --> 00:51:12.000
 you're triggering is very asynchronous,

00:51:12.000 --> 00:51:14.980
 but like your fuzz task has already stopped

00:51:14.980 --> 00:51:17.720
 and it doesn't get executed anymore?

00:51:17.720 --> 00:51:20.120
 - Not to, we're not aware of that.

00:51:20.120 --> 00:51:22.040
 I don't think that happened because we're really like,

00:51:22.040 --> 00:51:23.940
 we're the lowest possible priority

00:51:23.940 --> 00:51:26.560
 and every call control stuff is higher priority.

00:51:26.560 --> 00:51:28.120
 So the schedule will always just schedule

00:51:28.120 --> 00:51:29.400
 everything higher than us.

00:51:29.400 --> 00:51:32.080
 - And also another thing is persistent mode, right?

00:51:32.080 --> 00:51:34.060
 We implemented this persistent lock at some point.

00:51:34.060 --> 00:51:37.080
 So basically persistent mode, the work would be done

00:51:37.080 --> 00:51:38.800
 and then the next fuzz iteration,

00:51:38.800 --> 00:51:41.040
 like the basement continues, the fuzz task gets scheduled in,

00:51:41.040 --> 00:51:42.120
 send the next input.

00:51:42.120 --> 00:51:44.440
 By then maybe side condition happens.

00:51:44.440 --> 00:51:47.040
 Triaging gets a bit messy at this point,

00:51:47.040 --> 00:51:49.280
 but could in theory be done.

00:51:49.280 --> 00:51:52.360
 - So essentially every message is like always processed

00:51:52.360 --> 00:51:54.640
 instantly and there's not like a queue

00:51:54.640 --> 00:51:57.040
 where some task checks it periodically

00:51:57.040 --> 00:51:58.960
 or something like that?

00:51:58.960 --> 00:52:00.320
 - Not in the stuff we looked at.

00:52:00.320 --> 00:52:02.620
 Probably that can happen, but then you will have

00:52:02.620 --> 00:52:04.440
 to find some way to, yeah.

00:52:04.440 --> 00:52:07.880
 - Yeah, I mean one thing to say is also we specifically

00:52:07.880 --> 00:52:10.800
 looked into pre-authentication messages because this is

00:52:10.800 --> 00:52:14.560
 like one of the most lucrative attack targets, right?

00:52:14.560 --> 00:52:17.520
 As it just taken as is and usually pre-authentication,

00:52:17.520 --> 00:52:19.040
 there's not a lot of state yet.

00:52:19.040 --> 00:52:20.780
 - Yeah, and you don't, I mean the cool thing

00:52:20.780 --> 00:52:22.840
 about pre-auth stuff is that it's simple

00:52:22.840 --> 00:52:27.840
 and you don't need any, like you can just send this

00:52:27.840 --> 00:52:29.040
 as a rogue base station.

00:52:29.040 --> 00:52:32.640
 You don't need to be in any case like a proper,

00:52:32.640 --> 00:52:37.640
 benign cellular person or yeah, anyway.

00:52:37.640 --> 00:52:41.400
 Anyway, you see my brain is already fried.

00:52:41.400 --> 00:52:43.600
 Thank you so much for your time.

00:52:43.600 --> 00:52:46.760
 (audience applauding)

00:52:52.000 --> 00:52:56.000
 [Music]

