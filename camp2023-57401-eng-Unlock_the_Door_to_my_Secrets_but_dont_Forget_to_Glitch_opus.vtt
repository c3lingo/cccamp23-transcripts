WEBVTT

00:00:00.000 --> 00:00:10.000
 [MUSIC]

00:00:10.000 --> 00:00:17.000
 Okay.

00:00:17.000 --> 00:00:34.600
 Hello everybody and welcome back to the Millie Way Stage here.

00:00:34.600 --> 00:00:38.040
 We will have your presentation starting at two o'clock shortly.

00:00:38.040 --> 00:00:41.960
 Just got some general announcements and information for you all.

00:00:41.960 --> 00:00:45.400
 Don't forget to wash your hands, be healthy, be safe.

00:00:45.400 --> 00:00:47.480
 Basic COVID precautions.

00:00:47.480 --> 00:00:50.560
 Unfortunately, we haven't had zero incidences.

00:00:50.560 --> 00:00:54.920
 There are masks and test kits available at the info desk,

00:00:54.920 --> 00:00:57.520
 if anybody feels like they would like to make use of them.

00:00:57.520 --> 00:01:03.640
 But just be safe and wonderful and excellent people and washing your hands goes a long way.

00:01:03.640 --> 00:01:05.200
 Also general announcement,

00:01:05.200 --> 00:01:08.920
 if anybody has any unused but still usable items that they're

00:01:08.920 --> 00:01:11.560
 packing down and not going to be taking home,

00:01:11.560 --> 00:01:15.040
 they are taking donations at the info desk as well.

00:01:15.040 --> 00:01:18.720
 If you want to drop off things like extra tents or food,

00:01:18.720 --> 00:01:20.240
 as long as it's non-perishable,

00:01:20.240 --> 00:01:25.240
 they'll be taking collections there so you have a little bit less to pack in and take with you.

00:01:25.240 --> 00:01:27.560
 One other thing, I hope anybody,

00:01:27.560 --> 00:01:29.280
 have you all seen a talk here yet at Millie Way?

00:01:29.280 --> 00:01:32.520
 Has anybody enjoyed the movie last night or see some good stuff?

00:01:32.520 --> 00:01:36.320
 Well, hopefully you'll enjoy a couple more here. What was that?

00:01:36.320 --> 00:01:39.600
 Oh, who was here for karaoke last night?

00:01:39.600 --> 00:01:42.120
 Okay. Well, yeah, you weren't here this morning,

00:01:42.120 --> 00:01:45.240
 but I could still hear you at 6 AM.

00:01:45.240 --> 00:01:47.120
 So yeah, thanks for that.

00:01:47.120 --> 00:01:49.960
 So speaking of, this stage is being put on by Millie Way's,

00:01:49.960 --> 00:01:53.320
 which is the camp just behind us and also has the restaurant,

00:01:53.320 --> 00:01:55.420
 of course, at the end of the universe.

00:01:55.420 --> 00:01:57.240
 You're all welcome to join, hang out,

00:01:57.240 --> 00:02:00.400
 have some food, always appreciate donations and things like that.

00:02:00.400 --> 00:02:04.200
 But if you really want to chip in and be excellent and join us in

00:02:04.200 --> 00:02:07.200
 the solidarity of not losing too much money doing all of this,

00:02:07.200 --> 00:02:09.960
 we do still have some challenge coins available.

00:02:09.960 --> 00:02:12.760
 So Millie Way's creates these cool coins every year.

00:02:12.760 --> 00:02:17.360
 There's Millie Way's on one side and a 2023 on the flip.

00:02:17.360 --> 00:02:25.600
 This is a pretty cool silver edition and there are a now limited edition black coin as well.

00:02:25.600 --> 00:02:29.340
 So 30 euro or better donations are much appreciated.

00:02:29.340 --> 00:02:33.800
 You can hit me up here or the info desk right behind us also has more coins,

00:02:33.800 --> 00:02:35.760
 including ones from previous years.

00:02:35.760 --> 00:02:40.580
 So if you are at say 2017 or 2019,

00:02:40.580 --> 00:02:45.060
 Congress camps or otherwise and really miss one of those coins,

00:02:45.060 --> 00:02:47.940
 you can get one for an extra special offering.

00:02:47.940 --> 00:02:54.600
 So yeah, hope everybody enjoys their evening and we'll go ahead and get going here with what you all came for,

00:02:54.600 --> 00:02:56.160
 which is to see Mark.

00:02:56.160 --> 00:02:58.760
 Surpizer, that's not Mark.

00:02:58.760 --> 00:03:02.480
 This is the unlock the door to my secrets,

00:03:02.480 --> 00:03:04.040
 but don't forget to glitch.

00:03:04.040 --> 00:03:09.720
 Unfortunately, Mark is recovering and not able to physically get themselves here,

00:03:09.720 --> 00:03:15.520
 but has given Sylvan all the information and you fantastically offered to come and give it.

00:03:15.520 --> 00:03:17.480
 So we don't have an empty stage.

00:03:17.480 --> 00:03:21.440
 So with that, I would like to thank and welcome Sylvan to the stage,

00:03:21.440 --> 00:03:25.240
 presenting Mark's talk on unlock the door to my secrets,

00:03:25.240 --> 00:03:27.920
 but don't forget to glitch. The stage is yours.

00:03:27.920 --> 00:03:29.920
 Thank you. Thank you.

00:03:29.920 --> 00:03:38.800
 Okay, first of all, let's give a good recovery to Mark.

00:03:38.800 --> 00:03:42.600
 He would have loved to be here,

00:03:42.600 --> 00:03:45.600
 but I hope I can represent him well enough.

00:03:45.600 --> 00:03:49.600
 First of all, about me slides, it's not about me, it's about Mark.

00:03:49.600 --> 00:03:54.000
 We both work at Fraunhofer, so the first part is still the same.

00:03:54.000 --> 00:03:56.000
 We do hardware security.

00:03:56.000 --> 00:04:02.800
 Mark is focused on embedded system security and does fault and side channel analysis,

00:04:02.800 --> 00:04:06.520
 but he's also an open source contributor to OpenOCD,

00:04:06.520 --> 00:04:09.840
 the well-loved debugger, libjlink, and others.

00:04:09.840 --> 00:04:11.880
 If you want to know more about Mark,

00:04:11.880 --> 00:04:14.880
 if you don't know him yet, you can follow his blog.

00:04:14.880 --> 00:04:19.240
 But about me very quickly,

00:04:19.240 --> 00:04:21.480
 I also do fault and side channel analysis,

00:04:21.480 --> 00:04:23.480
 but I'm more on the analysis side.

00:04:23.480 --> 00:04:28.760
 So I hope I can answer your questions if you have any well enough,

00:04:28.760 --> 00:04:31.920
 but my focus is not so much on the embedded part,

00:04:31.920 --> 00:04:34.400
 but more on the analysis part after.

00:04:34.400 --> 00:04:38.400
 But about the microcontrollers that we'll be looking at today.

00:04:38.400 --> 00:04:40.040
 First of all, we have microcontrollers.

00:04:40.040 --> 00:04:43.240
 We have one here, but they're omnipresent, they're everywhere.

00:04:43.240 --> 00:04:46.160
 You have them in your tokens, in your crypto wallets.

00:04:46.160 --> 00:04:49.120
 You have them also in your smart thermostats.

00:04:49.120 --> 00:04:51.840
 You have them pretty much in all embedded devices.

00:04:51.840 --> 00:04:54.960
 But they might contain some secrets in the tokens and crypto wallets.

00:04:54.960 --> 00:04:56.400
 It's an easy thing.

00:04:56.400 --> 00:04:58.440
 They have cryptographic keys, but also the others.

00:04:58.440 --> 00:05:01.800
 They have some intellectual properties that you might want to use,

00:05:01.800 --> 00:05:04.400
 that you might want to alter, that you might want to read out.

00:05:04.400 --> 00:05:06.160
 But of course, the manufacturer,

00:05:06.160 --> 00:05:10.520
 the producer of such a device doesn't want you to.

00:05:10.520 --> 00:05:14.600
 So our research is trying to find new attack vectors for this,

00:05:14.600 --> 00:05:16.080
 new hardware attacks.

00:05:16.080 --> 00:05:19.640
 But our goal is not only just to break them,

00:05:19.640 --> 00:05:21.000
 but to make things more secure.

00:05:21.000 --> 00:05:25.280
 So we have a responsible disclosure process still running on

00:05:25.280 --> 00:05:27.560
 about all these things in order for the manufacturers

00:05:27.560 --> 00:05:30.640
 to make things better, hopefully.

00:05:30.640 --> 00:05:35.320
 On this specific one, we have hardware faults that are there.

00:05:35.320 --> 00:05:39.360
 So it's hard to improve on the already out there products.

00:05:39.360 --> 00:05:42.720
 But we'll come to that later.

00:05:42.720 --> 00:05:45.720
 First of all, what's this talk about is about debug protection.

00:05:45.720 --> 00:05:48.200
 You have a device, you're programming, you're developing it.

00:05:48.200 --> 00:05:50.320
 You have full debug access, of course.

00:05:50.320 --> 00:05:52.440
 So you have access to everything and of course,

00:05:52.440 --> 00:05:57.400
 are able to read out and write to the flash memory.

00:05:57.400 --> 00:05:58.760
 Once you want to ship this product,

00:05:58.760 --> 00:06:00.360
 you want to make it ready for release,

00:06:00.360 --> 00:06:04.440
 you want to switch to limited debug access.

00:06:04.440 --> 00:06:06.800
 So during this, in this phase, you

00:06:06.800 --> 00:06:08.800
 have no access to the flash memory.

00:06:08.800 --> 00:06:10.320
 You can't read or write to it.

00:06:10.320 --> 00:06:12.400
 But you can still access some of the debug features

00:06:12.400 --> 00:06:16.200
 in order for a device to see if it's still running,

00:06:16.200 --> 00:06:18.360
 if there's some other problems with it

00:06:18.360 --> 00:06:22.960
 that you could do some checks on the memory and stuff,

00:06:22.960 --> 00:06:26.160
 if it's still working or if there's some hardware fault.

00:06:26.160 --> 00:06:28.680
 Some devices also have a full debug lockdown,

00:06:28.680 --> 00:06:31.880
 full debug disable, the full debug access.

00:06:31.880 --> 00:06:33.280
 However, that's not very common.

00:06:33.280 --> 00:06:34.640
 In most microcontrollers, they only

00:06:34.640 --> 00:06:36.160
 have this limited debug access.

00:06:36.160 --> 00:06:39.560
 And this is essentially the path that we're looking at today,

00:06:39.560 --> 00:06:41.720
 how to get back from this limited debug access

00:06:41.720 --> 00:06:44.920
 to full debug access without losing the content.

00:06:44.920 --> 00:06:46.440
 So you have the limited debug accesses.

00:06:46.440 --> 00:06:49.680
 You're able to, for example, use the SRAM

00:06:49.680 --> 00:06:51.480
 to write a program to the device to run it,

00:06:51.480 --> 00:06:54.360
 but you can't run the flash at the same time.

00:06:54.360 --> 00:06:58.360
 But you can do a flash and unlock an erase function

00:06:58.360 --> 00:07:00.400
 in order to get back.

00:07:00.400 --> 00:07:03.200
 And that's actually the problem.

00:07:03.200 --> 00:07:05.440
 If you go back, you erase all the memory content.

00:07:05.440 --> 00:07:08.240
 And that's the goal of today's talk,

00:07:08.240 --> 00:07:11.120
 was how to access this secret, how to unlock

00:07:11.120 --> 00:07:13.240
 the secret with the glitch.

00:07:13.240 --> 00:07:15.640
 So the glitch comes in exactly here,

00:07:15.640 --> 00:07:19.880
 trying to glitch this mass erase function.

00:07:19.880 --> 00:07:21.560
 How do we do that?

00:07:21.560 --> 00:07:25.240
 We first of all looked at the timing of how this flash

00:07:25.240 --> 00:07:26.280
 and erase function works.

00:07:26.280 --> 00:07:29.480
 So you're able to access the debug access

00:07:29.480 --> 00:07:31.040
 through the debug port.

00:07:31.040 --> 00:07:33.040
 You're able to access the device.

00:07:33.040 --> 00:07:35.880
 You're able to tell it, OK, I want to reset you.

00:07:35.880 --> 00:07:40.640
 I want to flash and erase the whole device.

00:07:40.640 --> 00:07:42.440
 Unlock it at the same time.

00:07:42.440 --> 00:07:46.160
 And this process is a simple command you give to the chip.

00:07:46.160 --> 00:07:48.560
 And it takes about 50 milliseconds.

00:07:48.560 --> 00:07:52.720
 And what we have here, it's an activity profile of the chip.

00:07:52.720 --> 00:07:55.840
 It's essentially over time how much power, how much activity

00:07:55.840 --> 00:07:57.800
 we have on the chip, how much power consumption

00:07:57.800 --> 00:07:59.280
 we have on the chip.

00:07:59.280 --> 00:08:02.240
 So you see in the areas where there's lots of peaks,

00:08:02.240 --> 00:08:04.320
 there's a lot of stuff happening.

00:08:04.320 --> 00:08:07.040
 And at the end and front, you have nothing happening.

00:08:07.040 --> 00:08:08.880
 And you have a small gap in between.

00:08:08.880 --> 00:08:10.320
 And so we analyzed this and looked

00:08:10.320 --> 00:08:13.960
 at what are the timings on this.

00:08:13.960 --> 00:08:16.600
 We have first, at the beginning, we

00:08:16.600 --> 00:08:19.360
 have a small part which we derived

00:08:19.360 --> 00:08:23.240
 to be the part where essentially the erase function is triggered.

00:08:23.240 --> 00:08:26.320
 So that's where the memory is actually erased.

00:08:26.320 --> 00:08:28.880
 And then we have a larger block where there's

00:08:28.880 --> 00:08:31.320
 something happening but that doesn't delete the memory

00:08:31.320 --> 00:08:31.800
 further.

00:08:31.800 --> 00:08:34.720
 We have another erase function part that's very similar.

00:08:34.720 --> 00:08:38.320
 You see the two parts are very much alike.

00:08:38.320 --> 00:08:39.720
 But it's just a little shorter.

00:08:39.720 --> 00:08:42.120
 That's the part where the settings are deleted.

00:08:42.120 --> 00:08:45.400
 So that's where the bit is deleted that essentially

00:08:45.400 --> 00:08:48.080
 locks the device down.

00:08:48.080 --> 00:08:51.440
 Then we have a similar large block doing some recovery parts.

00:08:51.440 --> 00:08:55.560
 And then we have five write operations which we decluded.

00:08:55.560 --> 00:08:57.840
 This is essentially where you write the five setting bytes

00:08:57.840 --> 00:09:01.760
 again, setting the initial setting to the chip,

00:09:01.760 --> 00:09:05.240
 writing what essentially this chip is from factory mode.

00:09:05.240 --> 00:09:06.800
 So essentially open debug access,

00:09:06.800 --> 00:09:11.280
 being able to read flash memory.

00:09:11.280 --> 00:09:12.240
 So what is our goal?

00:09:12.240 --> 00:09:16.000
 Our goal was to hinder the first operation,

00:09:16.000 --> 00:09:21.880
 hinder this erase function with a glitch.

00:09:21.880 --> 00:09:24.240
 So for this, we tested different devices.

00:09:24.240 --> 00:09:26.480
 So I have one device with me here today.

00:09:26.480 --> 00:09:28.280
 And on this device, I want to show you

00:09:28.280 --> 00:09:30.520
 what we do for the simple setup.

00:09:30.520 --> 00:09:34.680
 So we have a small developer board, an STM32 chip.

00:09:34.680 --> 00:09:38.200
 And first of all, of course, we connect it to power.

00:09:38.200 --> 00:09:41.200
 And then we want to be able to glitch the power supply.

00:09:41.200 --> 00:09:43.800
 So the first thing is remove some capacitors,

00:09:43.800 --> 00:09:45.960
 adjust the capacitance so you can actually

00:09:45.960 --> 00:09:49.560
 adjust the power supply without completely killing the chip,

00:09:49.560 --> 00:09:51.880
 but without all the capacitance just smoothing out

00:09:51.880 --> 00:09:55.080
 your glitch signal.

00:09:55.080 --> 00:09:57.480
 Then you want the chip to be more sensitive.

00:09:57.480 --> 00:10:01.360
 So you lower the supply voltage to the lower end of the specs.

00:10:01.360 --> 00:10:05.520
 So instead of 3.3 volts, you go down to 1.9 volts.

00:10:05.520 --> 00:10:07.320
 And then, of course, we want the debug access.

00:10:07.320 --> 00:10:09.200
 So we take out the debug ports.

00:10:09.200 --> 00:10:11.080
 We also will feed out a trigger signal.

00:10:11.080 --> 00:10:13.960
 So we will write a small command to the chip saying, OK,

00:10:13.960 --> 00:10:15.880
 pull up the trigger signal.

00:10:15.880 --> 00:10:17.320
 Do the flash and erase function.

00:10:17.320 --> 00:10:19.840
 And then we have a perfect timing for our glitch

00:10:19.840 --> 00:10:21.600
 to happen at the right time.

00:10:21.600 --> 00:10:23.480
 So we will take the glitch, which is essentially

00:10:23.480 --> 00:10:26.000
 just shortening the power supply for a very short time

00:10:26.000 --> 00:10:28.200
 in a specific shape.

00:10:28.200 --> 00:10:35.120
 For this, we use a device that just alters the power,

00:10:35.120 --> 00:10:36.920
 just shortens this for a very short time.

00:10:36.920 --> 00:10:44.520
 And that's essentially the setup for the demo I have here.

00:10:44.520 --> 00:10:45.760
 Let's switch to the demo.

00:10:45.760 --> 00:10:52.560
 Here we have the chip whisper board, which essentially

00:10:52.560 --> 00:10:54.080
 alters--

00:10:54.080 --> 00:10:56.360
 I hope you can see it--

00:10:56.360 --> 00:11:00.240
 which essentially alters, which is my debug interface, which

00:11:00.240 --> 00:11:02.000
 I have USB connection to.

00:11:02.000 --> 00:11:05.280
 And here I have the STM32 board that I just showed you.

00:11:05.280 --> 00:11:07.720
 I have all the wires connected, as I just showed you

00:11:07.720 --> 00:11:10.040
 in the previous slide.

00:11:10.040 --> 00:11:13.600
 And now you see the three LEDs.

00:11:13.600 --> 00:11:14.240
 Let me go back.

00:11:14.240 --> 00:11:16.760
 You have three LEDs on the chip here.

00:11:16.760 --> 00:11:19.080
 And you see them here blinking.

00:11:19.080 --> 00:11:19.880
 They should be blinking.

00:11:19.880 --> 00:11:21.960
 So that's essentially the program that we're running on

00:11:21.960 --> 00:11:22.760
 here right now.

00:11:22.760 --> 00:11:25.320
 You have three blinking LEDs.

00:11:25.320 --> 00:11:27.800
 And we want to read out the memory content of the flash

00:11:27.800 --> 00:11:30.080
 that runs this program.

00:11:30.080 --> 00:11:34.920
 So first, I will connect OpenOCD to the chip.

00:11:34.920 --> 00:11:37.880
 And this should probably hold the program, because once

00:11:37.880 --> 00:11:40.560
 you're in this limited debug access mode, you don't want

00:11:40.560 --> 00:11:43.360
 any interaction of the debug port to the flash memory.

00:11:43.360 --> 00:11:45.240
 So the chip has a direct--

00:11:45.240 --> 00:11:47.240
 the chip is locked right now.

00:11:47.240 --> 00:11:51.840
 So once I open the debug port, the chip holds program

00:11:51.840 --> 00:11:53.600
 execution from flash.

00:11:53.600 --> 00:11:58.440
 I can do my programming from the debug port, but the flash

00:11:58.440 --> 00:11:59.680
 memory is not used anymore.

00:11:59.680 --> 00:12:05.760
 So now we'll connect--

00:12:05.760 --> 00:12:07.840
 here on the left side, it will connect to the OpenOCD

00:12:07.840 --> 00:12:09.440
 debugger.

00:12:09.440 --> 00:12:13.240
 And it will just try to read out the memory.

00:12:13.240 --> 00:12:17.800
 So it will read out the flash memory here, 256 bytes, and it

00:12:17.800 --> 00:12:19.320
 fails.

00:12:19.320 --> 00:12:22.880
 The chip is locked right now, so I'm not able to read out

00:12:22.880 --> 00:12:25.480
 the memory.

00:12:25.480 --> 00:12:28.200
 And here, I already have the glitch set up.

00:12:28.200 --> 00:12:33.560
 The glitch script, this script tells this debugger, this chip

00:12:33.560 --> 00:12:37.440
 whisperer, to send the flash and erase, flash and unlock

00:12:37.440 --> 00:12:39.480
 command to the chip.

00:12:39.480 --> 00:12:40.640
 It will run it.

00:12:40.640 --> 00:12:44.480
 And just at that time, I have here the glitch connection,

00:12:44.480 --> 00:12:48.240
 which will trigger that glitch and interrupt the erase

00:12:48.240 --> 00:12:49.640
 function.

00:12:49.640 --> 00:12:50.900
 So let's try this.

00:12:51.500 --> 00:12:53.900
 And it's unlocked.

00:12:53.900 --> 00:12:55.140
 I can go back.

00:12:55.140 --> 00:13:01.940
 [APPLAUSE]

00:13:01.940 --> 00:13:04.300
 And I can read out the memory.

00:13:04.300 --> 00:13:05.900
 And now, if there's any secrets--

00:13:05.900 --> 00:13:08.140
 I mean, the secret code of how the Blinky lights are working.

00:13:08.140 --> 00:13:13.780
 Let's reset the chip so it's running again.

00:13:13.780 --> 00:13:17.020
 Now you see, even with the debug mode and debug access

00:13:17.020 --> 00:13:18.820
 activated, the chip is running.

00:13:18.820 --> 00:13:21.420
 So it's completely unlocked.

00:13:21.420 --> 00:13:23.140
 OK.

00:13:23.140 --> 00:13:25.660
 That's essentially the demo.

00:13:25.660 --> 00:13:27.420
 That brings me to the end of the talk already.

00:13:27.420 --> 00:13:32.860
 The glitch flash--

00:13:32.860 --> 00:13:37.140
 so I'm able to glitch the flash erase function to gain full

00:13:37.140 --> 00:13:37.980
 debug access.

00:13:37.980 --> 00:13:40.940
 So switching back from this limited debug access mode,

00:13:40.940 --> 00:13:44.260
 while glitching at the right time, I'm able to access all

00:13:44.260 --> 00:13:45.500
 the flash memory content.

00:13:45.500 --> 00:13:47.860
 I showed it to you on one specific microcontroller

00:13:47.860 --> 00:13:52.100
 here, because this is easy to bring set up for here.

00:13:52.100 --> 00:13:54.620
 We also tested-- or my colleague Mark tested multiple

00:13:54.620 --> 00:13:57.300
 different microcontrollers from different manufacturers,

00:13:57.300 --> 00:14:02.100
 which were all affected by a similar attack.

00:14:02.100 --> 00:14:05.980
 The results are still in the process of being published.

00:14:05.980 --> 00:14:09.140
 With responsible disclosure, everything in the paper right

00:14:09.140 --> 00:14:10.580
 now is under review.

00:14:10.580 --> 00:14:13.220
 So I can't show you the actual result.

00:14:13.220 --> 00:14:17.180
 It now is under review, so I actually don't know all the

00:14:17.180 --> 00:14:20.620
 details about which other ones, but there's multiple.

00:14:20.620 --> 00:14:23.460
 And maybe the most important thing for you is how to

00:14:23.460 --> 00:14:26.060
 protect yourself.

00:14:26.060 --> 00:14:28.100
 Yeah, you can apply specific mitigations.

00:14:28.100 --> 00:14:31.100
 For example, don't use the flash for very sensitive

00:14:31.100 --> 00:14:32.980
 content.

00:14:32.980 --> 00:14:36.100
 But the problem is you cannot really mitigate this attack

00:14:36.100 --> 00:14:37.980
 because it's essentially a hardware attack.

00:14:37.980 --> 00:14:40.700
 It's in the hardware of the device.

00:14:40.700 --> 00:14:42.620
 Yeah, that's essentially the end of the talk already.

00:14:42.620 --> 00:14:43.860
 If you have any questions--

00:14:43.860 --> 00:14:49.820
 Anybody here with questions, if you'd go ahead and line up

00:14:49.820 --> 00:14:52.140
 over here at the mic, and we'll take some questions.

00:14:52.140 --> 00:14:56.220
 First, let's thank not Mark Sylvan for a

00:14:56.220 --> 00:14:57.460
 fantastic talk today.

00:14:57.460 --> 00:15:04.380
 [APPLAUSE]

00:15:04.380 --> 00:15:06.180
 And we've got the first question for you.

00:15:06.180 --> 00:15:09.100
 Yeah, you're sat at the race for the talk.

00:15:09.100 --> 00:15:14.260
 You said that the erase function is prepended to the

00:15:14.260 --> 00:15:18.860
 function where the bits which do the protection are reset.

00:15:18.860 --> 00:15:24.140
 So what is your power supply timing to disable the erase

00:15:24.140 --> 00:15:26.500
 function, but enable the--

00:15:26.500 --> 00:15:28.940
 It's a very short glitch.

00:15:28.940 --> 00:15:33.540
 And then it just jumps over the chip erase to resetting the

00:15:33.540 --> 00:15:36.460
 bits where the flash is on.

00:15:36.460 --> 00:15:37.420
 I think you see it again.

00:15:37.420 --> 00:15:41.300
 You have the three parts, essentially.

00:15:41.300 --> 00:15:43.380
 And in the first part--

00:15:43.380 --> 00:15:44.380
 It's very difficult to see.

00:15:44.380 --> 00:15:45.020
 That's the problem.

00:15:45.020 --> 00:15:45.300
 Yeah.

00:15:45.300 --> 00:15:47.980
 So we'll mention here in the audience, the screen is a bit

00:15:47.980 --> 00:15:50.020
 difficult to see, but this is being recorded.

00:15:50.020 --> 00:15:55.140
 So just keep in mind, you can go back to media.ccc.de and

00:15:55.140 --> 00:15:58.940
 pull up the talk and get crystal clear HD on the slides

00:15:58.940 --> 00:16:01.020
 that may or may not be washed out.

00:16:01.020 --> 00:16:01.660
 OK.

00:16:01.660 --> 00:16:03.700
 About your question, it's like essentially it's a 50

00:16:03.700 --> 00:16:05.060
 millisecond time frame.

00:16:05.060 --> 00:16:06.100
 Where did you go?

00:16:06.100 --> 00:16:08.220
 It's a 50 millisecond time frame.

00:16:08.220 --> 00:16:10.620
 And you just do the glitch at the very beginning where the

00:16:10.620 --> 00:16:12.380
 memory content is erased.

00:16:12.380 --> 00:16:15.420
 And you just drop the power supply for a very short time.

00:16:15.420 --> 00:16:17.700
 That's essentially what this chip whisper is able to.

00:16:17.700 --> 00:16:21.220
 You just set settings essentially this short and

00:16:21.220 --> 00:16:22.660
 this very specific timing.

00:16:22.660 --> 00:16:26.140
 And you just hinder the chip from erasing the memory.

00:16:26.140 --> 00:16:30.100
 But essentially the bug here is that it still continues,

00:16:30.100 --> 00:16:31.300
 even though it didn't erase.

00:16:31.300 --> 00:16:34.380
 It says, OK, erase function didn't work.

00:16:34.380 --> 00:16:36.140
 Anyways, let's just unlock anyways.

00:16:36.140 --> 00:16:38.420
 So it should just--

00:16:38.420 --> 00:16:40.140
 if the erase doesn't work, it shouldn't unlock.

00:16:40.140 --> 00:16:44.060
 But unfortunately, it doesn't erase, but it still unlocks.

00:16:44.060 --> 00:16:45.460
 So that's what it's--

00:16:45.460 --> 00:16:47.500
 [INAUDIBLE]

00:16:47.500 --> 00:16:48.100
 Yeah.

00:16:48.100 --> 00:16:49.700
 It doesn't check that it's actually worked.

00:16:49.700 --> 00:16:52.340
 Yeah.

00:16:52.340 --> 00:16:55.460
 Are there not brownout detection circuits that will

00:16:55.460 --> 00:16:56.900
 prevent this?

00:16:56.900 --> 00:16:59.660
 Could the erase functionality detect a

00:16:59.660 --> 00:17:02.140
 brownout and try again?

00:17:02.140 --> 00:17:02.660
 It could.

00:17:02.660 --> 00:17:03.140
 Yeah, it could.

00:17:03.140 --> 00:17:04.380
 But it doesn't.

00:17:04.380 --> 00:17:12.060
 How can we reproduce this attack ourselves?

00:17:12.060 --> 00:17:17.340
 I don't know if the scripts are online or what the details

00:17:17.340 --> 00:17:19.740
 in the paper are.

00:17:19.740 --> 00:17:22.980
 But this chip whisper is ready, available.

00:17:22.980 --> 00:17:27.540
 And then it's just trying to figure out the exact timings.

00:17:27.540 --> 00:17:30.020
 But I guess you just have to wait for the paper which

00:17:30.020 --> 00:17:32.220
 information we are able to publish here.

00:17:32.220 --> 00:17:35.060
 Can you mention again which board is doing what here?

00:17:35.060 --> 00:17:37.060
 This board here on the left, that's a chip whisperer.

00:17:37.060 --> 00:17:39.820
 That's an off-the-shelf device for these kinds of hardware

00:17:39.820 --> 00:17:40.540
 attacks.

00:17:40.540 --> 00:17:42.700
 This essentially shapes the glitch.

00:17:42.700 --> 00:17:46.100
 And this is just a voltage conversion, this small board,

00:17:46.100 --> 00:17:48.060
 just to get this 1.9 volts.

00:17:48.060 --> 00:17:52.820
 And that's just an STM32 developer board, just off-the-shelf

00:17:52.820 --> 00:17:55.220
 developer board, which we removed and adjusted some of

00:17:55.220 --> 00:17:57.940
 the capacitors to have the right power supply.

00:17:57.940 --> 00:18:00.460
 So if you would have a product, you would maybe have to

00:18:00.460 --> 00:18:03.620
 desolder or adjust the capacitance.

00:18:03.620 --> 00:18:06.580
 But of course, as it's in the power supply, the capacitance,

00:18:06.580 --> 00:18:11.500
 you could also adjust it with adding capacitors here, which

00:18:11.500 --> 00:18:13.660
 we have one that's plugged in here.

00:18:13.660 --> 00:18:14.700
 Sorry for moving.

00:18:14.700 --> 00:18:15.700
 All right, and we'll say we've got a few

00:18:15.700 --> 00:18:17.100
 more questions for you.

00:18:17.100 --> 00:18:19.640
 Yeah, you said you've done this with multiple devices.

00:18:19.640 --> 00:18:25.700
 I'm just curious, how difficult is it to find a level to sort

00:18:25.700 --> 00:18:28.340
 of drop it out to that doesn't brown out the chip so it stops

00:18:28.340 --> 00:18:29.340
 executing code?

00:18:29.340 --> 00:18:32.780
 But still stops the flash erasing?

00:18:32.780 --> 00:18:34.540
 How hard is it to find the right timing?

00:18:34.540 --> 00:18:36.740
 It's like, is this an easy attack?

00:18:36.740 --> 00:18:39.380
 I'm always outside of the lab, so Mark is doing the real

00:18:39.380 --> 00:18:40.540
 work there.

00:18:40.540 --> 00:18:43.420
 And it does take some time.

00:18:43.420 --> 00:18:47.700
 So for example, we have the advantage to be able to

00:18:47.700 --> 00:18:49.700
 record and analyze the chip very detailed.

00:18:49.700 --> 00:18:53.100
 So we actually have a probe that we can set on top to

00:18:53.100 --> 00:18:55.820
 measure the electromagnetic emanation of the chip and

00:18:55.820 --> 00:18:59.180
 analyze what exactly is it doing or guess what it's doing.

00:18:59.180 --> 00:19:02.820
 And so we were able to look at these traces and see what the

00:19:02.820 --> 00:19:03.420
 timing is.

00:19:03.420 --> 00:19:04.620
 We tried it with different data.

00:19:04.620 --> 00:19:06.820
 We tried it with an empty chip, first of all, to

00:19:06.820 --> 00:19:08.980
 understand what's actually happening there.

00:19:08.980 --> 00:19:12.620
 And then once you know which operation is, then you can

00:19:12.620 --> 00:19:13.460
 adjust these timings.

00:19:13.460 --> 00:19:15.500
 And then, of course, you have a frame of--

00:19:15.500 --> 00:19:19.500
 you try short, long, intense glitches, different shapes.

00:19:19.500 --> 00:19:22.220
 And you just have a script run overnight, and it'll try

00:19:22.220 --> 00:19:23.460
 everything.

00:19:23.460 --> 00:19:28.380
 Do you have any idea which process you are

00:19:28.380 --> 00:19:30.180
 exactly affecting?

00:19:30.180 --> 00:19:31.220
 The erase function.

00:19:31.220 --> 00:19:34.140
 But I mean, which part of the erase function?

00:19:34.140 --> 00:19:37.340
 Is it maybe charging up power or something like this?

00:19:37.340 --> 00:19:38.620
 Or is it already erasing?

00:19:38.620 --> 00:19:42.140
 My guess, from the discussion with my colleague, it seems

00:19:42.140 --> 00:19:44.140
 like essentially we're dropping the power.

00:19:44.140 --> 00:19:47.860
 You know how a flash cell, in order to erase it, you need

00:19:47.860 --> 00:19:52.460
 power to essentially get electrons out of this floating

00:19:52.460 --> 00:19:53.460
 gate there.

00:19:53.460 --> 00:19:55.100
 And that needs a lot of power.

00:19:55.100 --> 00:19:57.140
 And essentially, when you take off the power at the time, it

00:19:57.140 --> 00:19:59.820
 might not pull the electrons out, the charge out.

00:19:59.820 --> 00:20:02.860
 And then you don't have an erase.

00:20:02.860 --> 00:20:04.180
 I think that's the guess.

00:20:04.180 --> 00:20:08.860
 But it's just an educated guess from a black box.

00:20:08.860 --> 00:20:13.420
 How many dev boards did you need to figure out the right

00:20:13.420 --> 00:20:15.140
 timing and all that?

00:20:15.140 --> 00:20:16.380
 I don't know.

00:20:16.380 --> 00:20:20.500
 Probably around 10, I would say.

00:20:20.500 --> 00:20:21.940
 I don't think we have a big pile now.

00:20:21.940 --> 00:20:24.460
 I don't know.

00:20:24.460 --> 00:20:27.780
 And do we have any questions from the internet?

00:20:27.780 --> 00:20:29.580
 And do we have any other questions?

00:20:29.580 --> 00:20:32.780
 We've got just another minute or two here if there's a

00:20:32.780 --> 00:20:35.380
 follow-up question.

00:20:35.380 --> 00:20:38.780
 What should we do if, for example, such an

00:20:38.780 --> 00:20:41.140
 error exists in a chip?

00:20:41.140 --> 00:20:46.540
 Should we choose another chip to prevent this?

00:20:46.540 --> 00:20:53.900
 Or is it just an error that's so difficult to reproduce that

00:20:53.900 --> 00:20:55.780
 we can ignore it?

00:20:55.780 --> 00:20:57.820
 It depends what you want to protect.

00:20:57.820 --> 00:21:01.140
 If you have an open source project on this, there's not

00:21:01.140 --> 00:21:01.860
 many assets.

00:21:01.860 --> 00:21:04.540
 Unless you have an open source project without any keys on

00:21:04.540 --> 00:21:08.700
 there, there's no asset that you're protecting.

00:21:08.700 --> 00:21:13.140
 But if you have intellectual properties that you don't want

00:21:13.140 --> 00:21:15.740
 to get distributed--

00:21:15.740 --> 00:21:18.260
 for example, for the cryptocrafter keys, you can use

00:21:18.260 --> 00:21:23.140
 a hardware chip, extra protected, secure chip.

00:21:23.140 --> 00:21:25.460
 But for the others, the problem is we only

00:21:25.460 --> 00:21:26.500
 have limited research.

00:21:26.500 --> 00:21:29.060
 I don't know if there was any chip that they couldn't

00:21:29.060 --> 00:21:29.900
 succeed.

00:21:29.900 --> 00:21:31.940
 But of course, that just means, OK, they didn't find

00:21:31.940 --> 00:21:34.660
 the glitch.

00:21:34.660 --> 00:21:38.660
 So it's hard to say, OK, use this chip instead.

00:21:38.660 --> 00:21:39.020
 All right.

00:21:39.020 --> 00:21:41.940
 So what do you think about glitching?

00:21:41.940 --> 00:21:44.660
 I imagine everybody here is somewhat familiar with glitch,

00:21:44.660 --> 00:21:46.700
 but we're talking all kinds of things-- glitching,

00:21:46.700 --> 00:21:48.580
 brownout, et cetera.

00:21:48.580 --> 00:21:51.140
 If we're trying to talk to you, maybe doesn't have a chip

00:21:51.140 --> 00:21:52.980
 whisper at home or whatever else, do you have a way to

00:21:52.980 --> 00:21:58.100
 summarize what is glitching in a not too technical way?

00:21:58.100 --> 00:22:03.180
 Glitching, it's essentially just like flickering the light

00:22:03.180 --> 00:22:04.260
 while it's running.

00:22:04.260 --> 00:22:08.180
 So just flickering with the power supply while the program

00:22:08.180 --> 00:22:12.460
 runs and giving some faulty operation with this,

00:22:12.460 --> 00:22:13.020
 essentially.

00:22:13.020 --> 00:22:15.940
 And the idea is if you do this dozens of times, millions of

00:22:15.940 --> 00:22:18.820
 times, eventually you'll get lucky.

00:22:18.820 --> 00:22:22.100
 And flipping that switch, it'll think, oh, I totally got

00:22:22.100 --> 00:22:24.300
 a valid command to do this other thing that I shouldn't

00:22:24.300 --> 00:22:25.980
 have access to do, but I'm going to do it anyways because

00:22:25.980 --> 00:22:26.820
 I don't know better.

00:22:26.820 --> 00:22:27.340
 Yeah, exactly.

00:22:27.340 --> 00:22:27.700
 Exactly.

00:22:27.700 --> 00:22:31.220
 But when you have this specific timing, you don't have

00:22:31.220 --> 00:22:31.740
 to get lucky.

00:22:31.740 --> 00:22:35.580
 Like this essentially runs every time now, once we have

00:22:35.580 --> 00:22:36.820
 the timing right.

00:22:36.820 --> 00:22:37.140
 Gotcha.

00:22:37.140 --> 00:22:37.820
 Very good.

00:22:37.820 --> 00:22:39.060
 Well, thank you so much.

00:22:39.060 --> 00:22:41.180
 And really appreciate the talk.

00:22:41.180 --> 00:22:43.700
 So once again, I'll retitle this slightly.

00:22:43.700 --> 00:22:48.580
 Sylvan and Mark's talk on Unlock the Door to My Secrets.

00:22:48.580 --> 00:22:49.620
 Thank you so much.

00:22:49.620 --> 00:22:49.980
 Thank you.

00:22:49.980 --> 00:22:57.580
 [APPLAUSE]

00:22:57.700 --> 00:23:02.660
 [MUSIC PLAYING]

